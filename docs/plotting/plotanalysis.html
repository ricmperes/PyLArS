<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pylars.plotting.plotanalysis API documentation</title>
<meta name="description" content="Collection of usefull functions to plot results and analysis intermediate
steps â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pylars.plotting.plotanalysis</code></h1>
</header>
<section id="section-intro">
<p>Collection of usefull functions to plot results and analysis intermediate
steps.</p>
<p>The file is divided into LED OFF and LED ON sections. Most of the functions
provide the plt axis object to facility the integration of these plots in
different figures as required.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Collection of usefull functions to plot results and analysis intermediate
steps.

The file is divided into LED OFF and LED ON sections. Most of the functions
provide the plt axis object to facility the integration of these plots in
different figures as required.
&#34;&#34;&#34;

from typing import Tuple, Union, Optional

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
from pylars.utils.common import Gaussian, func_linear

from .plotprocessed import *

##### LED ON #####


def plot_area_LED(bv_dataset, voltage, LED_position=300,
                  log_y=True, full_x=False, ax=None,
                  color=None):
    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(12, 6))

    df = bv_dataset.data[voltage]

    cut_mask = ((df[&#39;position&#39;] &gt; (LED_position - 10)) &amp;
                (df[&#39;position&#39;] &lt; (LED_position + 20)) &amp;
                (df[&#39;length&#39;] &gt; 3))

    ax = plot_hist_area(df[cut_mask], ax=ax, color=color)

    if full_x:
        ax.set_xlim(0, 2**14 * 10 * 300)
    if log_y:
        ax.set_yscale(&#39;log&#39;)

    ax.set_title((f&#39;LED ON\n module {bv_dataset.module} | &#39;
                  f&#39;channel {bv_dataset.channel[-1]}&#39;)
                 )

    med = np.median(df[cut_mask][&#39;area&#39;])
    std = np.std(df[cut_mask][&#39;area&#39;])
    med_err = std / np.sqrt(len(df[cut_mask]))

    return med, med_err, ax


def plot_LED_all_voltages(bv_dataset, cmap=&#39;winter&#39;, ax=None,):
    cm = plt.get_cmap(cmap)  # type: ignore
    N_lines = len(bv_dataset.voltages)

    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(12, 6))
    for i, _v in enumerate(bv_dataset.voltages):

        med, med_err, ax = plot_area_LED(bv_dataset, 50,
                                         color=cm(i / N_lines),
                                         ax=ax)
        ax.axvline(med, color=cm(i / N_lines))
        ax.set_title(&#39;&#39;)

    plt.show()


def plot_BV_fit(plot, temperature, voltages, gains,
                a, b, _breakdown_v, _breakdown_v_error, ax=None):

    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(6, 3), facecolor=&#39;white&#39;)

    ax.plot(gains, voltages,
            ls=&#39;&#39;, marker=&#39;x&#39;, c=&#39;k&#39;,
            label=(f&#39;{temperature}K: ({_breakdown_v:.2f}&#39;
                   f&#39;$\\pm${_breakdown_v_error:.2f}) V&#39;)  # type: ignore
            )
    _offset_gains = min(gains) * 0.15
    _x = np.linspace(min(gains) - _offset_gains,
                     max(gains) + _offset_gains,
                     100)
    ax.plot(_x, func_linear(_x, a, b), c=&#39;r&#39;, alpha=0.9)
    ax.set_xlabel(&#39;Gain&#39;)
    ax.set_ylabel(&#39;Voltage [V]&#39;)
    ax.legend()
    ax.set_title(plot)
    ax.ticklabel_format(style=&#39;sci&#39;, axis=&#39;x&#39;, scilimits=(0, 0),
                        useMathText=True)

    if isinstance(plot, str):
        plt.tight_layout()
        plt.savefig(f&#39;figures/{plot}_{temperature}_BV_fit.pdf&#39;)
        plt.close()
    else:
        return ax


def plot_BV_results(df_BV_results: pd.DataFrame,
                    all_channels: Union[list, tuple, np.ndarray],
                    r2_threshold: float = 0.,
                    ax=None):
    &#34;&#34;&#34;Plot the distribution of BV voltages for different channels.

    Args:
        df_BV_results (pd.DataFrame): df with the BV values, errors, r2 value
            of linear fit for eahc temperature and channel.
        all_channels (Union[list, tuple, np.ndarray]): the channel names,
            in order, to put on the x axis ticks. Usually &#34;(mod, ch)&#34; or
            &#34;#xxx&#34; for the MPPC number.
        r2_threshold (float, optional): cuts BVs with fits with r2 bellow this
             value. Defaults to 0.
        ax (plt.axis, optional): the axis to draw into. Defaults to None.
    &#34;&#34;&#34;
    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(6, 4))

    temps = df_BV_results.index.levels[0]  # type: ignore
    for t in temps:
        t_mask = ((df_BV_results[&#39;temp&#39;] == t) &amp;
                  (df_BV_results[&#39;r2&#39;] &gt; r2_threshold)
                  )
        _df = df_BV_results[t_mask]

        ax.errorbar(_df.index.codes[1],  # type: ignore
                    _df[&#39;BV&#39;],
                    yerr=_df[&#39;BV_std&#39;],
                    ls=&#39;&#39;, marker=&#39;.&#39;, capsize=4,
                    label=f&#39;{t:.0f} K&#39;)

    ax.legend()
    ax.set_xticks(df_BV_results.index.levels[1],  # type: ignore
                  all_channels, rotation=30)

    return ax

##### LED OFF #####


def plot_DCR_curve(plot: Union[str, bool, None], area_hist_x: np.ndarray,
                   DCR_values: np.ndarray, _x: np.ndarray,
                   _y: np.ndarray, min_area_x: float, ax=None):
    &#34;&#34;&#34;Make the DCR step plot.

    Args:
        plot (Optional[str]): string to save the fgiure with a name, None to
            return the axis
        area_hist_x (np.ndarray): x values on the step plot.
        DCR_values (np.ndarray): y values on the step plot.
        _x (np.ndarray): x values of the computed 1st derivative
        _y (np.ndarray): y values of the computed 1st derivative
        min_area_x (float): area of minimum of the derivative function
        ax (_type_, optional): Axis where to draw. Creates one if ax=None.
            Defaults to None.

    Returns:
        None or axis: the axis drawn at if `plot` not a str, None if `plot`
            is a string
    &#34;&#34;&#34;

    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(12, 5), facecolor=&#39;white&#39;)
    ax.plot(area_hist_x, DCR_values,
            marker=&#39;x&#39;, ls=&#39;&#39;,
            c=&#39;k&#39;, label=&#39;Data points&#39;)
    ax.set_yscale(&#39;log&#39;)
    ax.set_xlabel(&#39;Area [integrated ADC counts]&#39;)
    ax.set_ylabel(&#39;# events&#39;)

    ax3 = ax.twinx()
    ax3.plot(_x, _y, c=&#39;r&#39;)
    ax3.tick_params(axis=&#39;y&#39;, labelcolor=&#39;r&#39;)
    ax3.axvline(min_area_x, c=&#39;r&#39;, ls=&#39;--&#39;, alpha=0.8,
                label=&#39;1$^{st}$ der. (smoothed)&#39;)
    ax3.set_ylabel(&#39;1$^{st}$ derivative&#39;)

    if &#39;fig&#39; in locals():
        fig.legend()  # type: ignore

    if isinstance(plot, str):
        fig.savefig(f&#39;figures/{plot}_stepplot.png&#39;)  # type: ignore
        plt.close()
    else:
        return ax


def plot_SPE_fit(df, length_cut_min, length_cut_max, plot, area_hist_x,
                 min_area_x, A, mu, sigma, ax=None):

    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(12, 5), facecolor=&#39;white&#39;)
    bin_size = area_hist_x[1] - area_hist_x[0]
    ax.hist(df[(df[&#39;length&#39;] &gt; length_cut_min) &amp;
               (df[&#39;length&#39;] &lt; length_cut_max)][&#39;area&#39;],
            bins=np.linspace(0.5 * min_area_x, 1.5 * min_area_x, 300),
            color=&#39;gray&#39;, alpha=0.8)

    _x = np.linspace(area_hist_x[0], area_hist_x[-1], 200)
    ax.plot(_x, Gaussian(_x, A, mu, sigma), color=&#39;red&#39;)
    ax.set_xlabel(&#39;Area [integrated ADC counts]&#39;)
    ax.set_ylabel(&#39;# events&#39;)
    for i in range(1, 4):
        ax.axvline(mu * i, color=&#39;red&#39;, ls=&#39;--&#39;, alpha=0.7)
        # plt.yscale(&#39;log&#39;)

    if isinstance(plot, str):
        plt.savefig(f&#39;figures/{plot}_1pe_fit.png&#39;)
        plt.close()
    else:
        return ax


def plot_found_area_peaks(area_x, area_y, area_filt, area_peaks_x,
                          plot=None, ax=None):

    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(12, 5), facecolor=&#39;white&#39;)

    ax.plot(area_x, area_y, color=&#39;k&#39;, alpha=0.7)  # , range = (100,1e4))

    ax.plot(area_x, area_filt, color=&#39;blue&#39;, ls=&#39;-&#39;, lw=1, alpha=1)

    ax.vlines(area_x[area_peaks_x], 0, 1e6, color=&#39;green&#39;, alpha=0.5)
    ax.set_xlabel(&#39;Area&#39;)
    ax.set_yscale(&#39;log&#39;)

    if isinstance(plot, str):
        plt.savefig(f&#39;figures/{plot}_paeks_and_valeys.png&#39;)
        plt.close()
    elif plot is True:
        plt.show()


def plot_results_ds(results: pd.DataFrame,
                    errorbars: bool = True,
                    figaxs: Union[None, Tuple] = None) -&gt; tuple:
    &#34;&#34;&#34;Summary plot of the DCR results of run.

    Args:
        results (pd.DataFrame): results df
        errorbars (bool, optional): plot with errorbars. Defaults to True.
        figaxs (Union[None, Tuple], optional): where to draw the plots. Creates
            if None. Defaults to None.

    Returns:
        tuple: the figure and ax objects (fig,ax)
    &#34;&#34;&#34;
    if figaxs is None:
        fig, axs = plt.subplots(4, sharex=True, sharey=False, figsize=(10, 8))
    else:
        fig, axs = figaxs
    fig.subplots_adjust(hspace=0)

    temps = np.unique(results[&#39;T&#39;])
    for _temp in temps:
        _select = results[&#39;T&#39;] == _temp
        if errorbars:
            axs[0].errorbar(results[_select][&#39;Gain&#39;],
                            results[_select][&#39;V&#39;],
                            xerr=results[_select][&#39;Gain_error&#39;],
                            ls=&#39;&#39;, capsize=4,
                            marker=&#39;.&#39;)  # , label = &#39;180 K&#39;)
            axs[1].errorbar(results[_select][&#39;Gain&#39;],
                            results[_select][&#39;SPE_res&#39;],
                            xerr=results[_select][&#39;Gain_error&#39;],
                            yerr=results[_select][&#39;SPE_res_error&#39;],
                            ls=&#39;&#39;, capsize=4,
                            marker=&#39;.&#39;, label=f&#39;{_temp:.0f} K&#39;)
            axs[2].errorbar(results[_select][&#39;Gain&#39;],
                            results[_select][&#39;DCR&#39;],
                            xerr=results[_select][&#39;Gain_error&#39;],
                            yerr=results[_select][&#39;DCR_error&#39;],
                            ls=&#39;&#39;, capsize=4,
                            marker=&#39;.&#39;)
            axs[3].errorbar(results[_select][&#39;Gain&#39;],
                            results[_select][&#39;CTP&#39;],
                            xerr=results[_select][&#39;Gain_error&#39;],
                            yerr=results[_select][&#39;CTP_error&#39;],
                            ls=&#39;&#39;, capsize=4,
                            marker=&#39;.&#39;)
        else:
            axs[0].plot(results[_select][&#39;Gain&#39;],
                        results[_select][&#39;V&#39;],
                        ls=&#39;&#39;,
                        marker=&#39;o&#39;, label=f&#39;{_temp:.0f} K&#39;)
            axs[1].plot(results[_select][&#39;Gain&#39;], results[_select][&#39;SPE_res&#39;],
                        ls=&#39;&#39;,
                        marker=&#39;o&#39;)  # , label = &#39;180 K&#39;)
            axs[2].plot(results[_select][&#39;Gain&#39;], results[_select][&#39;DCR&#39;],
                        ls=&#39;&#39;,
                        marker=&#39;o&#39;)
            axs[3].plot(results[_select][&#39;Gain&#39;], results[_select][&#39;CTP&#39;],
                        ls=&#39;&#39;,
                        marker=&#39;o&#39;)

    axs[0].set_ylabel(&#39;Bias Voltage [V]&#39;)
    axs[1].set_ylabel(&#39;SPE res [%]&#39;)
    axs[2].set_ylabel(&#39;DCR [Hz/mm$^2$]&#39;)
    axs[3].set_ylabel(&#39;CTP [%]&#39;)
    axs[3].set_ylim(0, 80)
    axs[-1].set_xlabel(&#39;Gain&#39;)
    axs[0].grid()
    axs[1].grid()
    axs[2].grid()
    axs[3].grid()

    fig.legend(bbox_to_anchor=[0.9, 0.84])

    return fig, axs


def plot_BV_DCRresults(df_BV_results: pd.DataFrame,
                       ch_names: Union[list, tuple, np.ndarray],
                       errorbars: bool = False,
                       figax=None) -&gt; tuple:
    &#34;&#34;&#34;Plot the distribution of BV voltages for different channels.

    Args:
        df_BV_results (pd.DataFrame): results of BV calculation from a DCR
            dataset with
            `pylars.analysis.breakdown.compute_BV_DCRds_results`
        ch_names(Union[list, tuple, np.ndarray]): names of the channels for
            the x axis
        errorbars (bool, optional): plot with errorbars. Defaults to True.
        figaxs (Union[None, Tuple], optional): where to draw the plots. Creates
            if None. Defaults to None.


    Returns:
        tuple: the figure and ax objects (fig,ax)
    &#34;&#34;&#34;
    if figax is None:
        fig, ax = plt.subplots(1, 1, figsize=(6, 4))
    else:
        fig, ax = figax

    temps = np.unique(df_BV_results[&#39;T&#39;])

    for t in temps:
        _df = df_BV_results[df_BV_results[&#39;T&#39;] == t]
        _df.reset_index(drop=True, inplace=True)

        if errorbars:
            ax.errorbar(_df.index, _df[&#39;BV&#39;],
                        yerr=_df[f&#39;BV_error&#39;],
                        label=f&#39;{t} K&#39;,
                        ls=&#39;&#39;, marker=&#39;.&#39;, capsize=4)

        else:
            ax.plot(_df.index, _df[&#39;BV&#39;],
                    label=f&#39;{t} K&#39;, ls=&#39;&#39;,
                    marker=&#39;o&#39;)
    ax.legend()
    ax.set_xticks(_df.index, ch_names, rotation=30)  # type: ignore
    fig.set_tight_layout(True)

    return fig, ax


def plot_parameter_for_V(results_df: pd.DataFrame, V: float,
                         parameter: str, ch_names: list,
                         errorbars: bool = False):
    &#34;&#34;&#34;Plot the results from DCR analysis for a specific parameter
    (Gain, SPE_res, DCR, CTP) and applied voltage for all the recorded
    channels.

    Args:
        results_df (pd.DataFrame): DCR analysis results dataset.
        V (float): voltage.
        parameter (str): parameter to plot.
        ch_names (list): list with the names to assign to the channels.
        errorbars (bool, optional): include errorbars in plot. Defaults
            to False.

    Returns:
        (fig, ax): The figure and axis objects created.
    &#34;&#34;&#34;

    fig, ax = plt.subplots(1, 1, figsize=(8, 5))
    temps = np.unique(results_df[&#39;T&#39;])
    for t in temps:
        _df = results_df[(results_df[&#39;V&#39;] == V) &amp; (results_df[&#39;T&#39;] == t)]
        _df.reset_index(drop=True, inplace=True)

        if len(_df) == 0:
            print(f&#39;Found no points for {V} V at {t} K.&#39;)
            continue

        if errorbars:
            ax.errorbar(_df.index, _df[parameter],
                        yerr=_df[f&#39;{parameter}_error&#39;],
                        label=f&#39;{t} K&#39;,
                        ls=&#39;&#39;, marker=&#39;.&#39;, capsize=4)

        else:
            ax.plot(_df.index, _df[parameter],
                    label=f&#39;{t} K&#39;, ls=&#39;&#39;,
                    marker=&#39;o&#39;)
    ax.legend(title=f&#39;@{V} V&#39;)
    ax.set_ylabel(parameter)
    ax.set_xticks(_df.index, ch_names, rotation=30)  # type: ignore
    fig.set_tight_layout(True)

    return fig, ax</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pylars.plotting.plotanalysis.plot_BV_DCRresults"><code class="name flex">
<span>def <span class="ident">plot_BV_DCRresults</span></span>(<span>df_BV_results:Â pandas.core.frame.DataFrame, ch_names:Â Union[list,Â tuple,Â numpy.ndarray], errorbars:Â boolÂ =Â False, figax=None) â€‘>Â tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the distribution of BV voltages for different channels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df_BV_results</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>results of BV calculation from a DCR
dataset with
<code><a title="pylars.analysis.breakdown.compute_BV_DCRds_results" href="../analysis/breakdown.html#pylars.analysis.breakdown.compute_BV_DCRds_results">compute_BV_DCRds_results()</a></code></dd>
<dt>ch_names(Union[list, tuple, np.ndarray]): names of the channels for</dt>
<dt>the x axis</dt>
<dt><strong><code>errorbars</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>plot with errorbars. Defaults to True.</dd>
<dt><strong><code>figaxs</code></strong> :&ensp;<code>Union[None, Tuple]</code>, optional</dt>
<dd>where to draw the plots. Creates
if None. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>the figure and ax objects (fig,ax)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_BV_DCRresults(df_BV_results: pd.DataFrame,
                       ch_names: Union[list, tuple, np.ndarray],
                       errorbars: bool = False,
                       figax=None) -&gt; tuple:
    &#34;&#34;&#34;Plot the distribution of BV voltages for different channels.

    Args:
        df_BV_results (pd.DataFrame): results of BV calculation from a DCR
            dataset with
            `pylars.analysis.breakdown.compute_BV_DCRds_results`
        ch_names(Union[list, tuple, np.ndarray]): names of the channels for
            the x axis
        errorbars (bool, optional): plot with errorbars. Defaults to True.
        figaxs (Union[None, Tuple], optional): where to draw the plots. Creates
            if None. Defaults to None.


    Returns:
        tuple: the figure and ax objects (fig,ax)
    &#34;&#34;&#34;
    if figax is None:
        fig, ax = plt.subplots(1, 1, figsize=(6, 4))
    else:
        fig, ax = figax

    temps = np.unique(df_BV_results[&#39;T&#39;])

    for t in temps:
        _df = df_BV_results[df_BV_results[&#39;T&#39;] == t]
        _df.reset_index(drop=True, inplace=True)

        if errorbars:
            ax.errorbar(_df.index, _df[&#39;BV&#39;],
                        yerr=_df[f&#39;BV_error&#39;],
                        label=f&#39;{t} K&#39;,
                        ls=&#39;&#39;, marker=&#39;.&#39;, capsize=4)

        else:
            ax.plot(_df.index, _df[&#39;BV&#39;],
                    label=f&#39;{t} K&#39;, ls=&#39;&#39;,
                    marker=&#39;o&#39;)
    ax.legend()
    ax.set_xticks(_df.index, ch_names, rotation=30)  # type: ignore
    fig.set_tight_layout(True)

    return fig, ax</code></pre>
</details>
</dd>
<dt id="pylars.plotting.plotanalysis.plot_BV_fit"><code class="name flex">
<span>def <span class="ident">plot_BV_fit</span></span>(<span>plot, temperature, voltages, gains, a, b, _breakdown_v, _breakdown_v_error, ax=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_BV_fit(plot, temperature, voltages, gains,
                a, b, _breakdown_v, _breakdown_v_error, ax=None):

    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(6, 3), facecolor=&#39;white&#39;)

    ax.plot(gains, voltages,
            ls=&#39;&#39;, marker=&#39;x&#39;, c=&#39;k&#39;,
            label=(f&#39;{temperature}K: ({_breakdown_v:.2f}&#39;
                   f&#39;$\\pm${_breakdown_v_error:.2f}) V&#39;)  # type: ignore
            )
    _offset_gains = min(gains) * 0.15
    _x = np.linspace(min(gains) - _offset_gains,
                     max(gains) + _offset_gains,
                     100)
    ax.plot(_x, func_linear(_x, a, b), c=&#39;r&#39;, alpha=0.9)
    ax.set_xlabel(&#39;Gain&#39;)
    ax.set_ylabel(&#39;Voltage [V]&#39;)
    ax.legend()
    ax.set_title(plot)
    ax.ticklabel_format(style=&#39;sci&#39;, axis=&#39;x&#39;, scilimits=(0, 0),
                        useMathText=True)

    if isinstance(plot, str):
        plt.tight_layout()
        plt.savefig(f&#39;figures/{plot}_{temperature}_BV_fit.pdf&#39;)
        plt.close()
    else:
        return ax</code></pre>
</details>
</dd>
<dt id="pylars.plotting.plotanalysis.plot_BV_results"><code class="name flex">
<span>def <span class="ident">plot_BV_results</span></span>(<span>df_BV_results:Â pandas.core.frame.DataFrame, all_channels:Â Union[list,Â tuple,Â numpy.ndarray], r2_threshold:Â floatÂ =Â 0.0, ax=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the distribution of BV voltages for different channels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df_BV_results</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>df with the BV values, errors, r2 value
of linear fit for eahc temperature and channel.</dd>
<dt><strong><code>all_channels</code></strong> :&ensp;<code>Union[list, tuple, np.ndarray]</code></dt>
<dd>the channel names,
in order, to put on the x axis ticks. Usually "(mod, ch)" or
"#xxx" for the MPPC number.</dd>
<dt><strong><code>r2_threshold</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>cuts BVs with fits with r2 bellow this
value. Defaults to 0.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>plt.axis</code>, optional</dt>
<dd>the axis to draw into. Defaults to None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_BV_results(df_BV_results: pd.DataFrame,
                    all_channels: Union[list, tuple, np.ndarray],
                    r2_threshold: float = 0.,
                    ax=None):
    &#34;&#34;&#34;Plot the distribution of BV voltages for different channels.

    Args:
        df_BV_results (pd.DataFrame): df with the BV values, errors, r2 value
            of linear fit for eahc temperature and channel.
        all_channels (Union[list, tuple, np.ndarray]): the channel names,
            in order, to put on the x axis ticks. Usually &#34;(mod, ch)&#34; or
            &#34;#xxx&#34; for the MPPC number.
        r2_threshold (float, optional): cuts BVs with fits with r2 bellow this
             value. Defaults to 0.
        ax (plt.axis, optional): the axis to draw into. Defaults to None.
    &#34;&#34;&#34;
    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(6, 4))

    temps = df_BV_results.index.levels[0]  # type: ignore
    for t in temps:
        t_mask = ((df_BV_results[&#39;temp&#39;] == t) &amp;
                  (df_BV_results[&#39;r2&#39;] &gt; r2_threshold)
                  )
        _df = df_BV_results[t_mask]

        ax.errorbar(_df.index.codes[1],  # type: ignore
                    _df[&#39;BV&#39;],
                    yerr=_df[&#39;BV_std&#39;],
                    ls=&#39;&#39;, marker=&#39;.&#39;, capsize=4,
                    label=f&#39;{t:.0f} K&#39;)

    ax.legend()
    ax.set_xticks(df_BV_results.index.levels[1],  # type: ignore
                  all_channels, rotation=30)

    return ax</code></pre>
</details>
</dd>
<dt id="pylars.plotting.plotanalysis.plot_DCR_curve"><code class="name flex">
<span>def <span class="ident">plot_DCR_curve</span></span>(<span>plot:Â Union[str,Â bool,Â NoneType], area_hist_x:Â numpy.ndarray, DCR_values:Â numpy.ndarray, _x:Â numpy.ndarray, _y:Â numpy.ndarray, min_area_x:Â float, ax=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Make the DCR step plot.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plot</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>string to save the fgiure with a name, None to
return the axis</dd>
<dt><strong><code>area_hist_x</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>x values on the step plot.</dd>
<dt><strong><code>DCR_values</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>y values on the step plot.</dd>
<dt><strong><code>_x</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>x values of the computed 1st derivative</dd>
<dt><strong><code>_y</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>y values of the computed 1st derivative</dd>
<dt><strong><code>min_area_x</code></strong> :&ensp;<code>float</code></dt>
<dd>area of minimum of the derivative function</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>_type_</code>, optional</dt>
<dd>Axis where to draw. Creates one if ax=None.
Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code> or <code>axis</code></dt>
<dd>the axis drawn at if <code>plot</code> not a str, None if <code>plot</code>
is a string</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_DCR_curve(plot: Union[str, bool, None], area_hist_x: np.ndarray,
                   DCR_values: np.ndarray, _x: np.ndarray,
                   _y: np.ndarray, min_area_x: float, ax=None):
    &#34;&#34;&#34;Make the DCR step plot.

    Args:
        plot (Optional[str]): string to save the fgiure with a name, None to
            return the axis
        area_hist_x (np.ndarray): x values on the step plot.
        DCR_values (np.ndarray): y values on the step plot.
        _x (np.ndarray): x values of the computed 1st derivative
        _y (np.ndarray): y values of the computed 1st derivative
        min_area_x (float): area of minimum of the derivative function
        ax (_type_, optional): Axis where to draw. Creates one if ax=None.
            Defaults to None.

    Returns:
        None or axis: the axis drawn at if `plot` not a str, None if `plot`
            is a string
    &#34;&#34;&#34;

    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(12, 5), facecolor=&#39;white&#39;)
    ax.plot(area_hist_x, DCR_values,
            marker=&#39;x&#39;, ls=&#39;&#39;,
            c=&#39;k&#39;, label=&#39;Data points&#39;)
    ax.set_yscale(&#39;log&#39;)
    ax.set_xlabel(&#39;Area [integrated ADC counts]&#39;)
    ax.set_ylabel(&#39;# events&#39;)

    ax3 = ax.twinx()
    ax3.plot(_x, _y, c=&#39;r&#39;)
    ax3.tick_params(axis=&#39;y&#39;, labelcolor=&#39;r&#39;)
    ax3.axvline(min_area_x, c=&#39;r&#39;, ls=&#39;--&#39;, alpha=0.8,
                label=&#39;1$^{st}$ der. (smoothed)&#39;)
    ax3.set_ylabel(&#39;1$^{st}$ derivative&#39;)

    if &#39;fig&#39; in locals():
        fig.legend()  # type: ignore

    if isinstance(plot, str):
        fig.savefig(f&#39;figures/{plot}_stepplot.png&#39;)  # type: ignore
        plt.close()
    else:
        return ax</code></pre>
</details>
</dd>
<dt id="pylars.plotting.plotanalysis.plot_LED_all_voltages"><code class="name flex">
<span>def <span class="ident">plot_LED_all_voltages</span></span>(<span>bv_dataset, cmap='winter', ax=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_LED_all_voltages(bv_dataset, cmap=&#39;winter&#39;, ax=None,):
    cm = plt.get_cmap(cmap)  # type: ignore
    N_lines = len(bv_dataset.voltages)

    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(12, 6))
    for i, _v in enumerate(bv_dataset.voltages):

        med, med_err, ax = plot_area_LED(bv_dataset, 50,
                                         color=cm(i / N_lines),
                                         ax=ax)
        ax.axvline(med, color=cm(i / N_lines))
        ax.set_title(&#39;&#39;)

    plt.show()</code></pre>
</details>
</dd>
<dt id="pylars.plotting.plotanalysis.plot_SPE_fit"><code class="name flex">
<span>def <span class="ident">plot_SPE_fit</span></span>(<span>df, length_cut_min, length_cut_max, plot, area_hist_x, min_area_x, A, mu, sigma, ax=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_SPE_fit(df, length_cut_min, length_cut_max, plot, area_hist_x,
                 min_area_x, A, mu, sigma, ax=None):

    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(12, 5), facecolor=&#39;white&#39;)
    bin_size = area_hist_x[1] - area_hist_x[0]
    ax.hist(df[(df[&#39;length&#39;] &gt; length_cut_min) &amp;
               (df[&#39;length&#39;] &lt; length_cut_max)][&#39;area&#39;],
            bins=np.linspace(0.5 * min_area_x, 1.5 * min_area_x, 300),
            color=&#39;gray&#39;, alpha=0.8)

    _x = np.linspace(area_hist_x[0], area_hist_x[-1], 200)
    ax.plot(_x, Gaussian(_x, A, mu, sigma), color=&#39;red&#39;)
    ax.set_xlabel(&#39;Area [integrated ADC counts]&#39;)
    ax.set_ylabel(&#39;# events&#39;)
    for i in range(1, 4):
        ax.axvline(mu * i, color=&#39;red&#39;, ls=&#39;--&#39;, alpha=0.7)
        # plt.yscale(&#39;log&#39;)

    if isinstance(plot, str):
        plt.savefig(f&#39;figures/{plot}_1pe_fit.png&#39;)
        plt.close()
    else:
        return ax</code></pre>
</details>
</dd>
<dt id="pylars.plotting.plotanalysis.plot_area_LED"><code class="name flex">
<span>def <span class="ident">plot_area_LED</span></span>(<span>bv_dataset, voltage, LED_position=300, log_y=True, full_x=False, ax=None, color=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_area_LED(bv_dataset, voltage, LED_position=300,
                  log_y=True, full_x=False, ax=None,
                  color=None):
    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(12, 6))

    df = bv_dataset.data[voltage]

    cut_mask = ((df[&#39;position&#39;] &gt; (LED_position - 10)) &amp;
                (df[&#39;position&#39;] &lt; (LED_position + 20)) &amp;
                (df[&#39;length&#39;] &gt; 3))

    ax = plot_hist_area(df[cut_mask], ax=ax, color=color)

    if full_x:
        ax.set_xlim(0, 2**14 * 10 * 300)
    if log_y:
        ax.set_yscale(&#39;log&#39;)

    ax.set_title((f&#39;LED ON\n module {bv_dataset.module} | &#39;
                  f&#39;channel {bv_dataset.channel[-1]}&#39;)
                 )

    med = np.median(df[cut_mask][&#39;area&#39;])
    std = np.std(df[cut_mask][&#39;area&#39;])
    med_err = std / np.sqrt(len(df[cut_mask]))

    return med, med_err, ax</code></pre>
</details>
</dd>
<dt id="pylars.plotting.plotanalysis.plot_found_area_peaks"><code class="name flex">
<span>def <span class="ident">plot_found_area_peaks</span></span>(<span>area_x, area_y, area_filt, area_peaks_x, plot=None, ax=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_found_area_peaks(area_x, area_y, area_filt, area_peaks_x,
                          plot=None, ax=None):

    if ax is None:
        fig, ax = plt.subplots(1, 1, figsize=(12, 5), facecolor=&#39;white&#39;)

    ax.plot(area_x, area_y, color=&#39;k&#39;, alpha=0.7)  # , range = (100,1e4))

    ax.plot(area_x, area_filt, color=&#39;blue&#39;, ls=&#39;-&#39;, lw=1, alpha=1)

    ax.vlines(area_x[area_peaks_x], 0, 1e6, color=&#39;green&#39;, alpha=0.5)
    ax.set_xlabel(&#39;Area&#39;)
    ax.set_yscale(&#39;log&#39;)

    if isinstance(plot, str):
        plt.savefig(f&#39;figures/{plot}_paeks_and_valeys.png&#39;)
        plt.close()
    elif plot is True:
        plt.show()</code></pre>
</details>
</dd>
<dt id="pylars.plotting.plotanalysis.plot_parameter_for_V"><code class="name flex">
<span>def <span class="ident">plot_parameter_for_V</span></span>(<span>results_df:Â pandas.core.frame.DataFrame, V:Â float, parameter:Â str, ch_names:Â list, errorbars:Â boolÂ =Â False)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot the results from DCR analysis for a specific parameter
(Gain, SPE_res, DCR, CTP) and applied voltage for all the recorded
channels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>results_df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>DCR analysis results dataset.</dd>
<dt><strong><code>V</code></strong> :&ensp;<code>float</code></dt>
<dd>voltage.</dd>
<dt><strong><code>parameter</code></strong> :&ensp;<code>str</code></dt>
<dd>parameter to plot.</dd>
<dt><strong><code>ch_names</code></strong> :&ensp;<code>list</code></dt>
<dd>list with the names to assign to the channels.</dd>
<dt><strong><code>errorbars</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>include errorbars in plot. Defaults
to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(fig, ax): The figure and axis objects created.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_parameter_for_V(results_df: pd.DataFrame, V: float,
                         parameter: str, ch_names: list,
                         errorbars: bool = False):
    &#34;&#34;&#34;Plot the results from DCR analysis for a specific parameter
    (Gain, SPE_res, DCR, CTP) and applied voltage for all the recorded
    channels.

    Args:
        results_df (pd.DataFrame): DCR analysis results dataset.
        V (float): voltage.
        parameter (str): parameter to plot.
        ch_names (list): list with the names to assign to the channels.
        errorbars (bool, optional): include errorbars in plot. Defaults
            to False.

    Returns:
        (fig, ax): The figure and axis objects created.
    &#34;&#34;&#34;

    fig, ax = plt.subplots(1, 1, figsize=(8, 5))
    temps = np.unique(results_df[&#39;T&#39;])
    for t in temps:
        _df = results_df[(results_df[&#39;V&#39;] == V) &amp; (results_df[&#39;T&#39;] == t)]
        _df.reset_index(drop=True, inplace=True)

        if len(_df) == 0:
            print(f&#39;Found no points for {V} V at {t} K.&#39;)
            continue

        if errorbars:
            ax.errorbar(_df.index, _df[parameter],
                        yerr=_df[f&#39;{parameter}_error&#39;],
                        label=f&#39;{t} K&#39;,
                        ls=&#39;&#39;, marker=&#39;.&#39;, capsize=4)

        else:
            ax.plot(_df.index, _df[parameter],
                    label=f&#39;{t} K&#39;, ls=&#39;&#39;,
                    marker=&#39;o&#39;)
    ax.legend(title=f&#39;@{V} V&#39;)
    ax.set_ylabel(parameter)
    ax.set_xticks(_df.index, ch_names, rotation=30)  # type: ignore
    fig.set_tight_layout(True)

    return fig, ax</code></pre>
</details>
</dd>
<dt id="pylars.plotting.plotanalysis.plot_results_ds"><code class="name flex">
<span>def <span class="ident">plot_results_ds</span></span>(<span>results:Â pandas.core.frame.DataFrame, errorbars:Â boolÂ =Â True, figaxs:Â Union[NoneType,Â Tuple]Â =Â None) â€‘>Â tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Summary plot of the DCR results of run.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>results</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>results df</dd>
<dt><strong><code>errorbars</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>plot with errorbars. Defaults to True.</dd>
<dt><strong><code>figaxs</code></strong> :&ensp;<code>Union[None, Tuple]</code>, optional</dt>
<dd>where to draw the plots. Creates
if None. Defaults to None.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>the figure and ax objects (fig,ax)</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_results_ds(results: pd.DataFrame,
                    errorbars: bool = True,
                    figaxs: Union[None, Tuple] = None) -&gt; tuple:
    &#34;&#34;&#34;Summary plot of the DCR results of run.

    Args:
        results (pd.DataFrame): results df
        errorbars (bool, optional): plot with errorbars. Defaults to True.
        figaxs (Union[None, Tuple], optional): where to draw the plots. Creates
            if None. Defaults to None.

    Returns:
        tuple: the figure and ax objects (fig,ax)
    &#34;&#34;&#34;
    if figaxs is None:
        fig, axs = plt.subplots(4, sharex=True, sharey=False, figsize=(10, 8))
    else:
        fig, axs = figaxs
    fig.subplots_adjust(hspace=0)

    temps = np.unique(results[&#39;T&#39;])
    for _temp in temps:
        _select = results[&#39;T&#39;] == _temp
        if errorbars:
            axs[0].errorbar(results[_select][&#39;Gain&#39;],
                            results[_select][&#39;V&#39;],
                            xerr=results[_select][&#39;Gain_error&#39;],
                            ls=&#39;&#39;, capsize=4,
                            marker=&#39;.&#39;)  # , label = &#39;180 K&#39;)
            axs[1].errorbar(results[_select][&#39;Gain&#39;],
                            results[_select][&#39;SPE_res&#39;],
                            xerr=results[_select][&#39;Gain_error&#39;],
                            yerr=results[_select][&#39;SPE_res_error&#39;],
                            ls=&#39;&#39;, capsize=4,
                            marker=&#39;.&#39;, label=f&#39;{_temp:.0f} K&#39;)
            axs[2].errorbar(results[_select][&#39;Gain&#39;],
                            results[_select][&#39;DCR&#39;],
                            xerr=results[_select][&#39;Gain_error&#39;],
                            yerr=results[_select][&#39;DCR_error&#39;],
                            ls=&#39;&#39;, capsize=4,
                            marker=&#39;.&#39;)
            axs[3].errorbar(results[_select][&#39;Gain&#39;],
                            results[_select][&#39;CTP&#39;],
                            xerr=results[_select][&#39;Gain_error&#39;],
                            yerr=results[_select][&#39;CTP_error&#39;],
                            ls=&#39;&#39;, capsize=4,
                            marker=&#39;.&#39;)
        else:
            axs[0].plot(results[_select][&#39;Gain&#39;],
                        results[_select][&#39;V&#39;],
                        ls=&#39;&#39;,
                        marker=&#39;o&#39;, label=f&#39;{_temp:.0f} K&#39;)
            axs[1].plot(results[_select][&#39;Gain&#39;], results[_select][&#39;SPE_res&#39;],
                        ls=&#39;&#39;,
                        marker=&#39;o&#39;)  # , label = &#39;180 K&#39;)
            axs[2].plot(results[_select][&#39;Gain&#39;], results[_select][&#39;DCR&#39;],
                        ls=&#39;&#39;,
                        marker=&#39;o&#39;)
            axs[3].plot(results[_select][&#39;Gain&#39;], results[_select][&#39;CTP&#39;],
                        ls=&#39;&#39;,
                        marker=&#39;o&#39;)

    axs[0].set_ylabel(&#39;Bias Voltage [V]&#39;)
    axs[1].set_ylabel(&#39;SPE res [%]&#39;)
    axs[2].set_ylabel(&#39;DCR [Hz/mm$^2$]&#39;)
    axs[3].set_ylabel(&#39;CTP [%]&#39;)
    axs[3].set_ylim(0, 80)
    axs[-1].set_xlabel(&#39;Gain&#39;)
    axs[0].grid()
    axs[1].grid()
    axs[2].grid()
    axs[3].grid()

    fig.legend(bbox_to_anchor=[0.9, 0.84])

    return fig, axs</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pylars.plotting" href="index.html">pylars.plotting</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="pylars.plotting.plotanalysis.plot_BV_DCRresults" href="#pylars.plotting.plotanalysis.plot_BV_DCRresults">plot_BV_DCRresults</a></code></li>
<li><code><a title="pylars.plotting.plotanalysis.plot_BV_fit" href="#pylars.plotting.plotanalysis.plot_BV_fit">plot_BV_fit</a></code></li>
<li><code><a title="pylars.plotting.plotanalysis.plot_BV_results" href="#pylars.plotting.plotanalysis.plot_BV_results">plot_BV_results</a></code></li>
<li><code><a title="pylars.plotting.plotanalysis.plot_DCR_curve" href="#pylars.plotting.plotanalysis.plot_DCR_curve">plot_DCR_curve</a></code></li>
<li><code><a title="pylars.plotting.plotanalysis.plot_LED_all_voltages" href="#pylars.plotting.plotanalysis.plot_LED_all_voltages">plot_LED_all_voltages</a></code></li>
<li><code><a title="pylars.plotting.plotanalysis.plot_SPE_fit" href="#pylars.plotting.plotanalysis.plot_SPE_fit">plot_SPE_fit</a></code></li>
<li><code><a title="pylars.plotting.plotanalysis.plot_area_LED" href="#pylars.plotting.plotanalysis.plot_area_LED">plot_area_LED</a></code></li>
<li><code><a title="pylars.plotting.plotanalysis.plot_found_area_peaks" href="#pylars.plotting.plotanalysis.plot_found_area_peaks">plot_found_area_peaks</a></code></li>
<li><code><a title="pylars.plotting.plotanalysis.plot_parameter_for_V" href="#pylars.plotting.plotanalysis.plot_parameter_for_V">plot_parameter_for_V</a></code></li>
<li><code><a title="pylars.plotting.plotanalysis.plot_results_ds" href="#pylars.plotting.plotanalysis.plot_results_ds">plot_results_ds</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>