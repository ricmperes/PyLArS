<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pylars.processing.peaks API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pylars.processing.peaks</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import numba as nb
from typing import Tuple, List

class peak_processing():
    &#34;&#34;&#34;All the things peaks. Peaks are sums of pulses found in waveforms.

    This class, by definition, is a collection of class methods related 
    to peak processing to be used in `peakprocessor`, where a processor 
    object is then constructed.
    &#34;&#34;&#34;       
    
    __version__ = &#39;0.0.1&#39;

    available_posrec_algos = [&#39;CoG&#39;]

    @classmethod
    def apply_ADCcounts_to_e(cls, waveforms_subtracted: np.ndarray, 
                             ADC_config: dict) -&gt; np.ndarray:
        &#34;&#34;&#34;Convert ADC counts/sample to charge.

        Applies the charge converting factor to waveforms to turn ADC counts 
        (which are integrated over 1 sample) to charge. `waveforms_subtracted` 
        can be one or more channels.

        Args:
            waveforms_subtracted (np.ndarray): value of ADC counts per sample 
                above calculate local baseline
            ADC_config (dict): dictionary with the ADC config

        Raises:
            ValueError: If the parsed ADC_config dictionary does not have the 
                required keys.

        Returns:
            np.ndarray: waveforms in charge.
        &#34;&#34;&#34;

        try:
            ADC_range = ADC_config[&#39;ADC_range&#39;]
            ADC_impedance = ADC_config[&#39;ADC_impedance&#39;]
            F_amp = ADC_config[&#39;F_amp&#39;]
            ADC_res = ADC_config[&#39;ADC_res&#39;]
            q_e = ADC_config[&#39;q_e&#39;]
            dt = ADC_config[&#39;dt&#39;]
        except:
            raise ValueError(&#39;The ADC_config dictionary is probably missing &#39; +
                             &#39;something.&#39;)
        
        to_e_constant = (ADC_range * dt / ADC_impedance / F_amp / 
                         ADC_res / q_e)

        waveforms_charge = waveforms_subtracted * to_e_constant

        return waveforms_charge

    @classmethod
    def apply_e_to_pe(cls,waveforms_charge: np.ndarray,
                      gains: np.ndarray) -&gt; np.ndarray: 
        &#34;&#34;&#34;Transform waveforms from charge to pe with gain per channel.

        Takes waveforms already converted to charge from ADC counts and an 
        array with the gains for each channel in units of [e/pe]. The ammount 
        of rows in the waveform array needs to be the same as the length of 
        the gains array.

        The gains array is assumed to be on the correct order in respect to 
        the order of channels in waveforms_charge.

        Args:
            waveforms_charge (_type_): _description_

        Returns:
            np.ndarray: 
        &#34;&#34;&#34;

        assert len(gains) == np.shape(waveforms_charge)[0], (&#39;&#39;&#39;Size of 
        gains and channels in waveforms array do not match.&#39;&#39;&#39;)

        waveforms_pe = (waveforms_charge.T / gains).T

        return waveforms_pe

    @classmethod
    def apply_baseline_subtract(cls, waveforms: np.ndarray, 
                                baselines:np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Apply baseline subtracting and flipping from negative to positive 
        pulses.

        Args:
             waveforms (np.ndarray): waveforms, all channels stacked by rows.
            baselines (np.ndarray): computed baselines, all channels stacked 
                by rows.

        Returns:
            np.ndarray: waveforms flipped and where 0 is local baseline.
        &#34;&#34;&#34;

        assert len(baselines) == np.shape(waveforms)[0], (&#39;&#39;&#39;Size of 
        baseines and channels in waveforms array do not match.&#39;&#39;&#39;)

        waveforms_subtracted = (baselines - waveforms.T).T  # type: ignore

        return waveforms_subtracted

    @classmethod
    def apply_waveforms_transform(cls, waveforms: np.ndarray,
                                  baselines: np.ndarray,
                                  gains: np.ndarray,
                                  ADC_config: dict) -&gt; np.ndarray:
        &#34;&#34;&#34;Converts waveforms from ADC counts/sample to pe/s.
        
        Takes the initials waveforms stacked for all channels and returns 
        the waveforms in converted pe/s space.

        Args:
            waveforms (np.ndarray): waveforms, all channels stacked by rows.
            baselines (np.ndarray): computed baselines, all channels stacked 
                by rows.
            gains (np.ndarray): gains, all channels stacked by rows.
            ADC_config (dict): dictionary with the specific digitizer configs.

        Returns:
            np.ndarray: transformed waveforms
        &#34;&#34;&#34;

        waveforms_subtracted = cls.apply_baseline_subtract(
            waveforms, baselines)
        waveforms_charge = cls.apply_ADCcounts_to_e(
            waveforms_subtracted, ADC_config)
        waveforms_pe = cls.apply_e_to_pe(waveforms_charge, gains)

        return waveforms_pe
    
    @classmethod
    def reorder_channel(cls, data_array: np.ndarray, 
                        index_reorder: list) -&gt; np.ndarray:
        &#34;&#34;&#34;Reorder columns of an ndarray, corresponding to changing the order 
        of channels to match the order in the sensor layout.
        
        Based on the following stack overflow thread: https://stackoverflow.
        com/questions/20265229/rearrange-columns-of-numpy-2d-array

        Args:
            data_array (np.ndarray): array where columns are different 
                channels
            index_reorder (list): list of indexes where the change in 
                `data_array` is i-&gt;index_reorder[i].

        Returns:
            np.ndarray: the original array with reordered collumns following 
                `index_reorder`.
        &#34;&#34;&#34;

        if len(np.shape(data_array)) == 1:
            data_array = np.array(data_array).reshape(1,len(data_array))
            
        idx = np.empty_like(index_reorder)
        idx[index_reorder] = np.arange(len(index_reorder))
        data_array[:] = data_array[:, idx]  # in-place modification of array

        return data_array

    @classmethod
    def get_sum_waveform(cls, waveforms_pe: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Sums the (transformed to pe/s) waveforms of all channels.

        Args:
            waveforms_pe (np.ndarray): array with waveforms from all the 
                channels.

        Returns:
            np.ndarray: Summed waveform.
        &#34;&#34;&#34;

        summed_waveform = np.sum(waveforms_pe, axis = 0)

        return summed_waveform

    @classmethod
    def get_sum_peak_start_end_above_min_area(cls, areas: List[float], 
        positions: List[int], lengths: List[int], 
        area_min: float) -&gt; Tuple[List[int], List[int]]:
        &#34;&#34;&#34;Determine the indexes of start and end of a peak, considering 
        only peaks with area above `area_min`.

        Returns:
            Tuple[List, List]: lists with the indexes of begin of peaks and 
                end of peaks.
        &#34;&#34;&#34;
        good_peaks_start = []
        good_peaks_end = []
        for _area, _position, _length in zip(areas, positions, lengths):
            if _area &gt; area_min:
                good_peaks_start.append(_position)
                good_peaks_end.append(_position + _length)
        return (good_peaks_start, good_peaks_end)

    @classmethod
    def get_area_per_sensor(cls, waveforms_pe: np.ndarray, 
                            peaks_start:List[int], 
                            peaks_end: List[int]) -&gt; np.ndarray:
        &#34;&#34;&#34;Computes the area per sensor of a given waveform set to be used 
        for hitpattern needs.

        Args:
            waveforms_pe (np.ndarray): waveforms in pe, one row per channel.
            peaks_start (List[int]): list with the start of peaks in the 
                summed waveform.
            peaks_end (List[int]): list with the end of peaks in the 
                summed waveform.

        Returns:
            np.ndarray: array with the area per channel for the peaks, each 
                row a peak.
        &#34;&#34;&#34;
        
        
        area_per_sensor = np.zeros((len(peaks_start), 
                                    np.shape(waveforms_pe)[0]))
        for i, (_p_start, _p_end) in enumerate(zip(peaks_start,peaks_end)):
            area_per_sensor[i,:] = np.sum(waveforms_pe[:,_p_start:_p_end],
                                        axis = 1)
        return area_per_sensor

    @classmethod
    def reconstruct_xy_position(cls, area_per_sensor: np.ndarray,
                                sensor_layout: np.ndarray,
                                algo: str = &#39;CoG&#39;) -&gt; np.ndarray:
        &#34;&#34;&#34;Computes xy position of event given a hitpattern from 
        area_per_sensor.

        Args:
            algo (str, optional): The algorithm to use in position 
                reconstruction. Defaults to &#39;CoG&#39;.

        Returns:
            np.ndarray: array with x,y reconstructed position. Each row a 
                different peak. pos[:,0] is the list of x, pos[:,1] the 
                list of y.
        &#34;&#34;&#34;

        if algo is not &#39;CoG&#39;:
            raise NotImplementedError(f&#39;&#39;&#39;The requested reconstruction 
            algorithm ({algo}) is not yet implemented, 
            try: {cls.available_posrec_algos}&#39;&#39;&#39;)

        area_tot = np.sum(area_per_sensor, axis = 1)
        # might not be exactly the same as calculated in `process_waveform`
        
        x = np.sum((area_per_sensor * sensor_layout[0,:].T)) / area_tot
        y = np.sum((area_per_sensor * sensor_layout[1,:].T)) / area_tot

        return np.vstack([x,y])


class peak():
    &#34;&#34;&#34;This is a peak (gipfel).
    &#34;&#34;&#34;


    def __init__(self, timestamp: int,
                 wf_number: int,
                 area: float,
                 length: int,
                 position: int,
                 amplitude: float,
                 area_per_sensor: np.ndarray):

        self.timestamp = timestamp
        self.wf_number = wf_number
        self.area = area
        self.length = length
        self.position = position
        self.amplitude = amplitude
        self.area_per_sensor = area_per_sensor

    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pylars.processing.peaks.peak"><code class="flex name class">
<span>class <span class="ident">peak</span></span>
<span>(</span><span>timestamp: int, wf_number: int, area: float, length: int, position: int, amplitude: float, area_per_sensor: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a peak (gipfel).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class peak():
    &#34;&#34;&#34;This is a peak (gipfel).
    &#34;&#34;&#34;


    def __init__(self, timestamp: int,
                 wf_number: int,
                 area: float,
                 length: int,
                 position: int,
                 amplitude: float,
                 area_per_sensor: np.ndarray):

        self.timestamp = timestamp
        self.wf_number = wf_number
        self.area = area
        self.length = length
        self.position = position
        self.amplitude = amplitude
        self.area_per_sensor = area_per_sensor</code></pre>
</details>
</dd>
<dt id="pylars.processing.peaks.peak_processing"><code class="flex name class">
<span>class <span class="ident">peak_processing</span></span>
</code></dt>
<dd>
<div class="desc"><p>All the things peaks. Peaks are sums of pulses found in waveforms.</p>
<p>This class, by definition, is a collection of class methods related
to peak processing to be used in <code>peakprocessor</code>, where a processor
object is then constructed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class peak_processing():
    &#34;&#34;&#34;All the things peaks. Peaks are sums of pulses found in waveforms.

    This class, by definition, is a collection of class methods related 
    to peak processing to be used in `peakprocessor`, where a processor 
    object is then constructed.
    &#34;&#34;&#34;       
    
    __version__ = &#39;0.0.1&#39;

    available_posrec_algos = [&#39;CoG&#39;]

    @classmethod
    def apply_ADCcounts_to_e(cls, waveforms_subtracted: np.ndarray, 
                             ADC_config: dict) -&gt; np.ndarray:
        &#34;&#34;&#34;Convert ADC counts/sample to charge.

        Applies the charge converting factor to waveforms to turn ADC counts 
        (which are integrated over 1 sample) to charge. `waveforms_subtracted` 
        can be one or more channels.

        Args:
            waveforms_subtracted (np.ndarray): value of ADC counts per sample 
                above calculate local baseline
            ADC_config (dict): dictionary with the ADC config

        Raises:
            ValueError: If the parsed ADC_config dictionary does not have the 
                required keys.

        Returns:
            np.ndarray: waveforms in charge.
        &#34;&#34;&#34;

        try:
            ADC_range = ADC_config[&#39;ADC_range&#39;]
            ADC_impedance = ADC_config[&#39;ADC_impedance&#39;]
            F_amp = ADC_config[&#39;F_amp&#39;]
            ADC_res = ADC_config[&#39;ADC_res&#39;]
            q_e = ADC_config[&#39;q_e&#39;]
            dt = ADC_config[&#39;dt&#39;]
        except:
            raise ValueError(&#39;The ADC_config dictionary is probably missing &#39; +
                             &#39;something.&#39;)
        
        to_e_constant = (ADC_range * dt / ADC_impedance / F_amp / 
                         ADC_res / q_e)

        waveforms_charge = waveforms_subtracted * to_e_constant

        return waveforms_charge

    @classmethod
    def apply_e_to_pe(cls,waveforms_charge: np.ndarray,
                      gains: np.ndarray) -&gt; np.ndarray: 
        &#34;&#34;&#34;Transform waveforms from charge to pe with gain per channel.

        Takes waveforms already converted to charge from ADC counts and an 
        array with the gains for each channel in units of [e/pe]. The ammount 
        of rows in the waveform array needs to be the same as the length of 
        the gains array.

        The gains array is assumed to be on the correct order in respect to 
        the order of channels in waveforms_charge.

        Args:
            waveforms_charge (_type_): _description_

        Returns:
            np.ndarray: 
        &#34;&#34;&#34;

        assert len(gains) == np.shape(waveforms_charge)[0], (&#39;&#39;&#39;Size of 
        gains and channels in waveforms array do not match.&#39;&#39;&#39;)

        waveforms_pe = (waveforms_charge.T / gains).T

        return waveforms_pe

    @classmethod
    def apply_baseline_subtract(cls, waveforms: np.ndarray, 
                                baselines:np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Apply baseline subtracting and flipping from negative to positive 
        pulses.

        Args:
             waveforms (np.ndarray): waveforms, all channels stacked by rows.
            baselines (np.ndarray): computed baselines, all channels stacked 
                by rows.

        Returns:
            np.ndarray: waveforms flipped and where 0 is local baseline.
        &#34;&#34;&#34;

        assert len(baselines) == np.shape(waveforms)[0], (&#39;&#39;&#39;Size of 
        baseines and channels in waveforms array do not match.&#39;&#39;&#39;)

        waveforms_subtracted = (baselines - waveforms.T).T  # type: ignore

        return waveforms_subtracted

    @classmethod
    def apply_waveforms_transform(cls, waveforms: np.ndarray,
                                  baselines: np.ndarray,
                                  gains: np.ndarray,
                                  ADC_config: dict) -&gt; np.ndarray:
        &#34;&#34;&#34;Converts waveforms from ADC counts/sample to pe/s.
        
        Takes the initials waveforms stacked for all channels and returns 
        the waveforms in converted pe/s space.

        Args:
            waveforms (np.ndarray): waveforms, all channels stacked by rows.
            baselines (np.ndarray): computed baselines, all channels stacked 
                by rows.
            gains (np.ndarray): gains, all channels stacked by rows.
            ADC_config (dict): dictionary with the specific digitizer configs.

        Returns:
            np.ndarray: transformed waveforms
        &#34;&#34;&#34;

        waveforms_subtracted = cls.apply_baseline_subtract(
            waveforms, baselines)
        waveforms_charge = cls.apply_ADCcounts_to_e(
            waveforms_subtracted, ADC_config)
        waveforms_pe = cls.apply_e_to_pe(waveforms_charge, gains)

        return waveforms_pe
    
    @classmethod
    def reorder_channel(cls, data_array: np.ndarray, 
                        index_reorder: list) -&gt; np.ndarray:
        &#34;&#34;&#34;Reorder columns of an ndarray, corresponding to changing the order 
        of channels to match the order in the sensor layout.
        
        Based on the following stack overflow thread: https://stackoverflow.
        com/questions/20265229/rearrange-columns-of-numpy-2d-array

        Args:
            data_array (np.ndarray): array where columns are different 
                channels
            index_reorder (list): list of indexes where the change in 
                `data_array` is i-&gt;index_reorder[i].

        Returns:
            np.ndarray: the original array with reordered collumns following 
                `index_reorder`.
        &#34;&#34;&#34;

        if len(np.shape(data_array)) == 1:
            data_array = np.array(data_array).reshape(1,len(data_array))
            
        idx = np.empty_like(index_reorder)
        idx[index_reorder] = np.arange(len(index_reorder))
        data_array[:] = data_array[:, idx]  # in-place modification of array

        return data_array

    @classmethod
    def get_sum_waveform(cls, waveforms_pe: np.ndarray) -&gt; np.ndarray:
        &#34;&#34;&#34;Sums the (transformed to pe/s) waveforms of all channels.

        Args:
            waveforms_pe (np.ndarray): array with waveforms from all the 
                channels.

        Returns:
            np.ndarray: Summed waveform.
        &#34;&#34;&#34;

        summed_waveform = np.sum(waveforms_pe, axis = 0)

        return summed_waveform

    @classmethod
    def get_sum_peak_start_end_above_min_area(cls, areas: List[float], 
        positions: List[int], lengths: List[int], 
        area_min: float) -&gt; Tuple[List[int], List[int]]:
        &#34;&#34;&#34;Determine the indexes of start and end of a peak, considering 
        only peaks with area above `area_min`.

        Returns:
            Tuple[List, List]: lists with the indexes of begin of peaks and 
                end of peaks.
        &#34;&#34;&#34;
        good_peaks_start = []
        good_peaks_end = []
        for _area, _position, _length in zip(areas, positions, lengths):
            if _area &gt; area_min:
                good_peaks_start.append(_position)
                good_peaks_end.append(_position + _length)
        return (good_peaks_start, good_peaks_end)

    @classmethod
    def get_area_per_sensor(cls, waveforms_pe: np.ndarray, 
                            peaks_start:List[int], 
                            peaks_end: List[int]) -&gt; np.ndarray:
        &#34;&#34;&#34;Computes the area per sensor of a given waveform set to be used 
        for hitpattern needs.

        Args:
            waveforms_pe (np.ndarray): waveforms in pe, one row per channel.
            peaks_start (List[int]): list with the start of peaks in the 
                summed waveform.
            peaks_end (List[int]): list with the end of peaks in the 
                summed waveform.

        Returns:
            np.ndarray: array with the area per channel for the peaks, each 
                row a peak.
        &#34;&#34;&#34;
        
        
        area_per_sensor = np.zeros((len(peaks_start), 
                                    np.shape(waveforms_pe)[0]))
        for i, (_p_start, _p_end) in enumerate(zip(peaks_start,peaks_end)):
            area_per_sensor[i,:] = np.sum(waveforms_pe[:,_p_start:_p_end],
                                        axis = 1)
        return area_per_sensor

    @classmethod
    def reconstruct_xy_position(cls, area_per_sensor: np.ndarray,
                                sensor_layout: np.ndarray,
                                algo: str = &#39;CoG&#39;) -&gt; np.ndarray:
        &#34;&#34;&#34;Computes xy position of event given a hitpattern from 
        area_per_sensor.

        Args:
            algo (str, optional): The algorithm to use in position 
                reconstruction. Defaults to &#39;CoG&#39;.

        Returns:
            np.ndarray: array with x,y reconstructed position. Each row a 
                different peak. pos[:,0] is the list of x, pos[:,1] the 
                list of y.
        &#34;&#34;&#34;

        if algo is not &#39;CoG&#39;:
            raise NotImplementedError(f&#39;&#39;&#39;The requested reconstruction 
            algorithm ({algo}) is not yet implemented, 
            try: {cls.available_posrec_algos}&#39;&#39;&#39;)

        area_tot = np.sum(area_per_sensor, axis = 1)
        # might not be exactly the same as calculated in `process_waveform`
        
        x = np.sum((area_per_sensor * sensor_layout[0,:].T)) / area_tot
        y = np.sum((area_per_sensor * sensor_layout[1,:].T)) / area_tot

        return np.vstack([x,y])</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pylars.processing.peaks.peak_processing.available_posrec_algos"><code class="name">var <span class="ident">available_posrec_algos</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="pylars.processing.peaks.peak_processing.apply_ADCcounts_to_e"><code class="name flex">
<span>def <span class="ident">apply_ADCcounts_to_e</span></span>(<span>waveforms_subtracted: numpy.ndarray, ADC_config: dict) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Convert ADC counts/sample to charge.</p>
<p>Applies the charge converting factor to waveforms to turn ADC counts
(which are integrated over 1 sample) to charge. <code>waveforms_subtracted</code>
can be one or more channels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>waveforms_subtracted</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>value of ADC counts per sample
above calculate local baseline</dd>
<dt><strong><code>ADC_config</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary with the ADC config</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the parsed ADC_config dictionary does not have the
required keys.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>waveforms in charge.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def apply_ADCcounts_to_e(cls, waveforms_subtracted: np.ndarray, 
                         ADC_config: dict) -&gt; np.ndarray:
    &#34;&#34;&#34;Convert ADC counts/sample to charge.

    Applies the charge converting factor to waveforms to turn ADC counts 
    (which are integrated over 1 sample) to charge. `waveforms_subtracted` 
    can be one or more channels.

    Args:
        waveforms_subtracted (np.ndarray): value of ADC counts per sample 
            above calculate local baseline
        ADC_config (dict): dictionary with the ADC config

    Raises:
        ValueError: If the parsed ADC_config dictionary does not have the 
            required keys.

    Returns:
        np.ndarray: waveforms in charge.
    &#34;&#34;&#34;

    try:
        ADC_range = ADC_config[&#39;ADC_range&#39;]
        ADC_impedance = ADC_config[&#39;ADC_impedance&#39;]
        F_amp = ADC_config[&#39;F_amp&#39;]
        ADC_res = ADC_config[&#39;ADC_res&#39;]
        q_e = ADC_config[&#39;q_e&#39;]
        dt = ADC_config[&#39;dt&#39;]
    except:
        raise ValueError(&#39;The ADC_config dictionary is probably missing &#39; +
                         &#39;something.&#39;)
    
    to_e_constant = (ADC_range * dt / ADC_impedance / F_amp / 
                     ADC_res / q_e)

    waveforms_charge = waveforms_subtracted * to_e_constant

    return waveforms_charge</code></pre>
</details>
</dd>
<dt id="pylars.processing.peaks.peak_processing.apply_baseline_subtract"><code class="name flex">
<span>def <span class="ident">apply_baseline_subtract</span></span>(<span>waveforms: numpy.ndarray, baselines: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Apply baseline subtracting and flipping from negative to positive
pulses.</p>
<h2 id="args">Args</h2>
<dl>
<dt>waveforms (np.ndarray): waveforms, all channels stacked by rows.</dt>
<dt><strong><code>baselines</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>computed baselines, all channels stacked
by rows.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>waveforms flipped and where 0 is local baseline.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def apply_baseline_subtract(cls, waveforms: np.ndarray, 
                            baselines:np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;Apply baseline subtracting and flipping from negative to positive 
    pulses.

    Args:
         waveforms (np.ndarray): waveforms, all channels stacked by rows.
        baselines (np.ndarray): computed baselines, all channels stacked 
            by rows.

    Returns:
        np.ndarray: waveforms flipped and where 0 is local baseline.
    &#34;&#34;&#34;

    assert len(baselines) == np.shape(waveforms)[0], (&#39;&#39;&#39;Size of 
    baseines and channels in waveforms array do not match.&#39;&#39;&#39;)

    waveforms_subtracted = (baselines - waveforms.T).T  # type: ignore

    return waveforms_subtracted</code></pre>
</details>
</dd>
<dt id="pylars.processing.peaks.peak_processing.apply_e_to_pe"><code class="name flex">
<span>def <span class="ident">apply_e_to_pe</span></span>(<span>waveforms_charge: numpy.ndarray, gains: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Transform waveforms from charge to pe with gain per channel.</p>
<p>Takes waveforms already converted to charge from ADC counts and an
array with the gains for each channel in units of [e/pe]. The ammount
of rows in the waveform array needs to be the same as the length of
the gains array.</p>
<p>The gains array is assumed to be on the correct order in respect to
the order of channels in waveforms_charge.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>waveforms_charge</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
</dl>
<h2 id="returns">Returns</h2>
<p>np.ndarray:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def apply_e_to_pe(cls,waveforms_charge: np.ndarray,
                  gains: np.ndarray) -&gt; np.ndarray: 
    &#34;&#34;&#34;Transform waveforms from charge to pe with gain per channel.

    Takes waveforms already converted to charge from ADC counts and an 
    array with the gains for each channel in units of [e/pe]. The ammount 
    of rows in the waveform array needs to be the same as the length of 
    the gains array.

    The gains array is assumed to be on the correct order in respect to 
    the order of channels in waveforms_charge.

    Args:
        waveforms_charge (_type_): _description_

    Returns:
        np.ndarray: 
    &#34;&#34;&#34;

    assert len(gains) == np.shape(waveforms_charge)[0], (&#39;&#39;&#39;Size of 
    gains and channels in waveforms array do not match.&#39;&#39;&#39;)

    waveforms_pe = (waveforms_charge.T / gains).T

    return waveforms_pe</code></pre>
</details>
</dd>
<dt id="pylars.processing.peaks.peak_processing.apply_waveforms_transform"><code class="name flex">
<span>def <span class="ident">apply_waveforms_transform</span></span>(<span>waveforms: numpy.ndarray, baselines: numpy.ndarray, gains: numpy.ndarray, ADC_config: dict) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Converts waveforms from ADC counts/sample to pe/s.</p>
<p>Takes the initials waveforms stacked for all channels and returns
the waveforms in converted pe/s space.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>waveforms</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>waveforms, all channels stacked by rows.</dd>
<dt><strong><code>baselines</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>computed baselines, all channels stacked
by rows.</dd>
<dt><strong><code>gains</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>gains, all channels stacked by rows.</dd>
<dt><strong><code>ADC_config</code></strong> :&ensp;<code>dict</code></dt>
<dd>dictionary with the specific digitizer configs.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>transformed waveforms</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def apply_waveforms_transform(cls, waveforms: np.ndarray,
                              baselines: np.ndarray,
                              gains: np.ndarray,
                              ADC_config: dict) -&gt; np.ndarray:
    &#34;&#34;&#34;Converts waveforms from ADC counts/sample to pe/s.
    
    Takes the initials waveforms stacked for all channels and returns 
    the waveforms in converted pe/s space.

    Args:
        waveforms (np.ndarray): waveforms, all channels stacked by rows.
        baselines (np.ndarray): computed baselines, all channels stacked 
            by rows.
        gains (np.ndarray): gains, all channels stacked by rows.
        ADC_config (dict): dictionary with the specific digitizer configs.

    Returns:
        np.ndarray: transformed waveforms
    &#34;&#34;&#34;

    waveforms_subtracted = cls.apply_baseline_subtract(
        waveforms, baselines)
    waveforms_charge = cls.apply_ADCcounts_to_e(
        waveforms_subtracted, ADC_config)
    waveforms_pe = cls.apply_e_to_pe(waveforms_charge, gains)

    return waveforms_pe</code></pre>
</details>
</dd>
<dt id="pylars.processing.peaks.peak_processing.get_area_per_sensor"><code class="name flex">
<span>def <span class="ident">get_area_per_sensor</span></span>(<span>waveforms_pe: numpy.ndarray, peaks_start: List[int], peaks_end: List[int]) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the area per sensor of a given waveform set to be used
for hitpattern needs.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>waveforms_pe</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>waveforms in pe, one row per channel.</dd>
<dt><strong><code>peaks_start</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>list with the start of peaks in the
summed waveform.</dd>
<dt><strong><code>peaks_end</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>list with the end of peaks in the
summed waveform.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>array with the area per channel for the peaks, each
row a peak.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_area_per_sensor(cls, waveforms_pe: np.ndarray, 
                        peaks_start:List[int], 
                        peaks_end: List[int]) -&gt; np.ndarray:
    &#34;&#34;&#34;Computes the area per sensor of a given waveform set to be used 
    for hitpattern needs.

    Args:
        waveforms_pe (np.ndarray): waveforms in pe, one row per channel.
        peaks_start (List[int]): list with the start of peaks in the 
            summed waveform.
        peaks_end (List[int]): list with the end of peaks in the 
            summed waveform.

    Returns:
        np.ndarray: array with the area per channel for the peaks, each 
            row a peak.
    &#34;&#34;&#34;
    
    
    area_per_sensor = np.zeros((len(peaks_start), 
                                np.shape(waveforms_pe)[0]))
    for i, (_p_start, _p_end) in enumerate(zip(peaks_start,peaks_end)):
        area_per_sensor[i,:] = np.sum(waveforms_pe[:,_p_start:_p_end],
                                    axis = 1)
    return area_per_sensor</code></pre>
</details>
</dd>
<dt id="pylars.processing.peaks.peak_processing.get_sum_peak_start_end_above_min_area"><code class="name flex">
<span>def <span class="ident">get_sum_peak_start_end_above_min_area</span></span>(<span>areas: List[float], positions: List[int], lengths: List[int], area_min: float) ‑> Tuple[List[int], List[int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Determine the indexes of start and end of a peak, considering
only peaks with area above <code>area_min</code>.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[List, List]</code></dt>
<dd>lists with the indexes of begin of peaks and
end of peaks.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_sum_peak_start_end_above_min_area(cls, areas: List[float], 
    positions: List[int], lengths: List[int], 
    area_min: float) -&gt; Tuple[List[int], List[int]]:
    &#34;&#34;&#34;Determine the indexes of start and end of a peak, considering 
    only peaks with area above `area_min`.

    Returns:
        Tuple[List, List]: lists with the indexes of begin of peaks and 
            end of peaks.
    &#34;&#34;&#34;
    good_peaks_start = []
    good_peaks_end = []
    for _area, _position, _length in zip(areas, positions, lengths):
        if _area &gt; area_min:
            good_peaks_start.append(_position)
            good_peaks_end.append(_position + _length)
    return (good_peaks_start, good_peaks_end)</code></pre>
</details>
</dd>
<dt id="pylars.processing.peaks.peak_processing.get_sum_waveform"><code class="name flex">
<span>def <span class="ident">get_sum_waveform</span></span>(<span>waveforms_pe: numpy.ndarray) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Sums the (transformed to pe/s) waveforms of all channels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>waveforms_pe</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>array with waveforms from all the
channels.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>Summed waveform.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_sum_waveform(cls, waveforms_pe: np.ndarray) -&gt; np.ndarray:
    &#34;&#34;&#34;Sums the (transformed to pe/s) waveforms of all channels.

    Args:
        waveforms_pe (np.ndarray): array with waveforms from all the 
            channels.

    Returns:
        np.ndarray: Summed waveform.
    &#34;&#34;&#34;

    summed_waveform = np.sum(waveforms_pe, axis = 0)

    return summed_waveform</code></pre>
</details>
</dd>
<dt id="pylars.processing.peaks.peak_processing.reconstruct_xy_position"><code class="name flex">
<span>def <span class="ident">reconstruct_xy_position</span></span>(<span>area_per_sensor: numpy.ndarray, sensor_layout: numpy.ndarray, algo: str = 'CoG') ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Computes xy position of event given a hitpattern from
area_per_sensor.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>algo</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The algorithm to use in position
reconstruction. Defaults to 'CoG'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>array with x,y reconstructed position. Each row a
different peak. pos[:,0] is the list of x, pos[:,1] the
list of y.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def reconstruct_xy_position(cls, area_per_sensor: np.ndarray,
                            sensor_layout: np.ndarray,
                            algo: str = &#39;CoG&#39;) -&gt; np.ndarray:
    &#34;&#34;&#34;Computes xy position of event given a hitpattern from 
    area_per_sensor.

    Args:
        algo (str, optional): The algorithm to use in position 
            reconstruction. Defaults to &#39;CoG&#39;.

    Returns:
        np.ndarray: array with x,y reconstructed position. Each row a 
            different peak. pos[:,0] is the list of x, pos[:,1] the 
            list of y.
    &#34;&#34;&#34;

    if algo is not &#39;CoG&#39;:
        raise NotImplementedError(f&#39;&#39;&#39;The requested reconstruction 
        algorithm ({algo}) is not yet implemented, 
        try: {cls.available_posrec_algos}&#39;&#39;&#39;)

    area_tot = np.sum(area_per_sensor, axis = 1)
    # might not be exactly the same as calculated in `process_waveform`
    
    x = np.sum((area_per_sensor * sensor_layout[0,:].T)) / area_tot
    y = np.sum((area_per_sensor * sensor_layout[1,:].T)) / area_tot

    return np.vstack([x,y])</code></pre>
</details>
</dd>
<dt id="pylars.processing.peaks.peak_processing.reorder_channel"><code class="name flex">
<span>def <span class="ident">reorder_channel</span></span>(<span>data_array: numpy.ndarray, index_reorder: list) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<div class="desc"><p>Reorder columns of an ndarray, corresponding to changing the order
of channels to match the order in the sensor layout.</p>
<p>Based on the following stack overflow thread: <a href="https://stackoverflow.">https://stackoverflow.</a>
com/questions/20265229/rearrange-columns-of-numpy-2d-array</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data_array</code></strong> :&ensp;<code>np.ndarray</code></dt>
<dd>array where columns are different
channels</dd>
<dt><strong><code>index_reorder</code></strong> :&ensp;<code>list</code></dt>
<dd>list of indexes where the change in
<code>data_array</code> is i-&gt;index_reorder[i].</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.ndarray</code></dt>
<dd>the original array with reordered collumns following
<code>index_reorder</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def reorder_channel(cls, data_array: np.ndarray, 
                    index_reorder: list) -&gt; np.ndarray:
    &#34;&#34;&#34;Reorder columns of an ndarray, corresponding to changing the order 
    of channels to match the order in the sensor layout.
    
    Based on the following stack overflow thread: https://stackoverflow.
    com/questions/20265229/rearrange-columns-of-numpy-2d-array

    Args:
        data_array (np.ndarray): array where columns are different 
            channels
        index_reorder (list): list of indexes where the change in 
            `data_array` is i-&gt;index_reorder[i].

    Returns:
        np.ndarray: the original array with reordered collumns following 
            `index_reorder`.
    &#34;&#34;&#34;

    if len(np.shape(data_array)) == 1:
        data_array = np.array(data_array).reshape(1,len(data_array))
        
    idx = np.empty_like(index_reorder)
    idx[index_reorder] = np.arange(len(index_reorder))
    data_array[:] = data_array[:, idx]  # in-place modification of array

    return data_array</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pylars.processing" href="index.html">pylars.processing</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pylars.processing.peaks.peak" href="#pylars.processing.peaks.peak">peak</a></code></h4>
</li>
<li>
<h4><code><a title="pylars.processing.peaks.peak_processing" href="#pylars.processing.peaks.peak_processing">peak_processing</a></code></h4>
<ul class="">
<li><code><a title="pylars.processing.peaks.peak_processing.apply_ADCcounts_to_e" href="#pylars.processing.peaks.peak_processing.apply_ADCcounts_to_e">apply_ADCcounts_to_e</a></code></li>
<li><code><a title="pylars.processing.peaks.peak_processing.apply_baseline_subtract" href="#pylars.processing.peaks.peak_processing.apply_baseline_subtract">apply_baseline_subtract</a></code></li>
<li><code><a title="pylars.processing.peaks.peak_processing.apply_e_to_pe" href="#pylars.processing.peaks.peak_processing.apply_e_to_pe">apply_e_to_pe</a></code></li>
<li><code><a title="pylars.processing.peaks.peak_processing.apply_waveforms_transform" href="#pylars.processing.peaks.peak_processing.apply_waveforms_transform">apply_waveforms_transform</a></code></li>
<li><code><a title="pylars.processing.peaks.peak_processing.available_posrec_algos" href="#pylars.processing.peaks.peak_processing.available_posrec_algos">available_posrec_algos</a></code></li>
<li><code><a title="pylars.processing.peaks.peak_processing.get_area_per_sensor" href="#pylars.processing.peaks.peak_processing.get_area_per_sensor">get_area_per_sensor</a></code></li>
<li><code><a title="pylars.processing.peaks.peak_processing.get_sum_peak_start_end_above_min_area" href="#pylars.processing.peaks.peak_processing.get_sum_peak_start_end_above_min_area">get_sum_peak_start_end_above_min_area</a></code></li>
<li><code><a title="pylars.processing.peaks.peak_processing.get_sum_waveform" href="#pylars.processing.peaks.peak_processing.get_sum_waveform">get_sum_waveform</a></code></li>
<li><code><a title="pylars.processing.peaks.peak_processing.reconstruct_xy_position" href="#pylars.processing.peaks.peak_processing.reconstruct_xy_position">reconstruct_xy_position</a></code></li>
<li><code><a title="pylars.processing.peaks.peak_processing.reorder_channel" href="#pylars.processing.peaks.peak_processing.reorder_channel">reorder_channel</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>