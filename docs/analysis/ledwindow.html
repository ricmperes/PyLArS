<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>pylars.analysis.ledwindow API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pylars.analysis.ledwindow</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import datetime
from typing import Tuple

import numpy as np
import pandas as pd
from scipy.optimize import curve_fit
from scipy.signal import find_peaks

import pylars


class LED_window():
    &#39;&#39;&#39;Class to hold analysis of LED ON data with integrating window.
    Use independently of BV datasets.
    &#39;&#39;&#39;

    def __init__(self,
                 led_window: Tuple[int, int],
                 led_data_path: str) -&gt; None:
        self.led_window = led_window
        self.led_data_path = led_data_path
        self.baseline_samples = 50
        self.files_df = self.find_files()

    def find_files(self) -&gt; pd.DataFrame:  # type: ignore
        &#39;&#39;&#39;Find the raw data file and the LED data file.
        TODO
        &#39;&#39;&#39;
        pass

        # files = glob.glob(self.led_data_path + &#39;**/*.root&#39;, recursive=True)
        # _dfs = []
        # for f in tqdm(files, desc=&#39;Finding LED data files: &#39;):
        #     try:
        #         _module = int(f.split(&#39;/&#39;)[-1].split(&#39;_&#39;)[4])
        #         _width, _voltage = self.get_LED_width_voltage(f)
        #         _dfs.append({&#39;LEDwidth&#39;: _width,
        #                      &#39;LEDvoltage&#39;: _voltage,
        #                      &#39;module&#39;: _module,
        #                      &#39;path&#39;: f})
        #     except:
        #         print(f&#39;Failed to get info for file {f}&#39;)
        #         continue
        # files_df = pd.DataFrame(_dfs)
        # files_df.sort_values(by=[&#39;LEDwidth&#39;, &#39;LEDvoltage&#39;, &#39;module&#39;],
        #              ignore_index = True, inplace=True)
        # del _dfs, files

        # return files_df

    @staticmethod
    def get_LED_width_voltage(path):
        &#34;&#34;&#34;Read LED width and voltage from the file path.&#34;&#34;&#34;

        root_name_list = path.split(&#39;/&#39;)[-1].split(&#39;_&#39;)
        pulser_width = int(root_name_list[0][:-2])
        voltage = float(root_name_list[1] + &#39;.&#39; + root_name_list[2][0])
        return pulser_width, voltage

    def process_dataset(self, data_path: str, module: int = 0) -&gt; pd.DataFrame:
        &#39;&#39;&#39;Process a dataset with fixwindowprocessor. Requires a raw data file
        and a LED window specified.
        &#39;&#39;&#39;

        processor = pylars.processing.fixwindowprocessor.window_processor(
            baseline_samples=self.baseline_samples,
            led_window=(self.led_window[0], self.led_window[1]))

        processor.load_raw_data(path_to_raw=data_path, module=module)
        df_processed = processor.process_all_channels()
        return df_processed

    def process_all_datasets(self) -&gt; None:
        &#39;&#39;&#39;Process all datasets in the LED data path.
        &#39;&#39;&#39;

        if not hasattr(self, &#39;files_df&#39;):
            raise AssertionError(&#39;No files found. Run find_files first.&#39;)

        _dfs = []
        # for i, row in tqdm(self.files_df.iterrows(),  # type: ignore
        #                    total=len(self.files_df),  # type: ignore
        #                    desc=&#39;Processing LED data: &#39;):^
        for i, row in self.files_df.iterrows():
            _df = self.process_dataset(row[&#39;path&#39;], module=row[&#39;module&#39;])
            _df[&#39;Vbias&#39;] = row[&#39;Vbias&#39;]
            _df[&#39;LEDwidth&#39;] = row[&#39;LEDwidth&#39;]
            _df[&#39;LEDvoltage&#39;] = row[&#39;LEDvoltage&#39;]
            _df[&#39;module&#39;] = row[&#39;module&#39;]
            _dfs.append(_df)
        df_processed = pd.concat(_dfs)
        del _dfs
        df_processed.sort_values(by=[&#39;Vbias&#39;, &#39;LEDvoltage&#39;,
                                     &#39;LEDwidth&#39;, &#39;module&#39;,
                                     &#39;channel&#39;, &#39;wf_number&#39;])

        self.df_processed = df_processed

    def check_settings_available(self):
        &#34;&#34;&#34;Set led_voltages, led_widths and sipms_voltages as object
        attributes.
        &#34;&#34;&#34;

        self.led_voltages = self.files_df[&#39;LEDvoltage&#39;].unique()
        self.led_widths = self.files_df[&#39;LEDwidth&#39;].unique()
        self.sipms_voltages = self.files_df[&#39;Vbias&#39;].unique()

    def get_1_pe_fit_led(self,
                         df_processed: pd.DataFrame,
                         module: int,
                         channel: str) -&gt; Tuple[float, float,
                                                float, np.ndarray]:
        &#34;&#34;&#34;Fit the SPE peak of an LED area hsitogram for a given module and
        channel. Uses scipy.curve_fit with a Gaussian function.

        Args:
            df_processed (pd.DataFrame): dataframe with processed data
            module (int): module to consider
            channel (str): channel to consider

        Returns:
            Tuple[float, float, float, np.ndarray]: A, mu, sigma,
                and cov resulting of the fit
        &#34;&#34;&#34;

        df_processed_mask = (
            (df_processed[&#39;module&#39;] == module) &amp;
            (df_processed[&#39;channel&#39;] == channel))

        hist = np.histogram(df_processed[df_processed_mask][&#39;led_area&#39;],
                            bins=np.linspace(-2000, 20000, 300))
        middle_bins = (hist[1][:-1] + hist[1][1:]) / 2

        try:
            peaks, properties = find_peaks(hist[0],
                                           prominence=100,
                                           distance=5)
            spe_rough = middle_bins[peaks[1]]
        except BaseException:
            spe_rough = 2500
        #if (spe_rough -2000) &gt; 1000: spe_rough = 2000

        spe_mask = np.abs(middle_bins - spe_rough) &lt; spe_rough * 0.5
        (A, mu, sigma), cov = curve_fit(pylars.utils.common.Gaussian,
                                        middle_bins[spe_mask],
                                        hist[0][spe_mask],
                                        p0=[2000, spe_rough,
                                            spe_rough * 0.05])
        return A, mu, sigma, cov

    def get_occupancy(self, results_one_channel: pd.DataFrame,
                      mu: float, mu_err: float,
                      method: str = &#39;mean&#39;) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;Calculate the occupancy of an LED dataset for a given channel.

        Args:
            results_one_channel (pd.DataFrame): dataframe with the results
                of a single channel
            mu (float): the SPE fit mean in ADCcounts
            mu_err (float): error in mu in ADCcounts
            method (str, optional): Method to calculate the occupancy. Either
                &#39;mean&#39; or &#39;median&#39;. Defaults to &#39;mean&#39;.

        Returns:
            Tuple[float, float]: Occupancy and its error. Uses mean by default!
        &#34;&#34;&#34;

        if method == &#39;mean&#39;:
            med = np.mean(results_one_channel[&#39;led_area&#39;])
        elif method == &#39;median&#39;:
            med = np.median(results_one_channel[&#39;led_area&#39;])
        else:
            raise ValueError(
                &#39;Method for occupancy calculation neither mean nor median&#39;)

        med_err = np.std(
            results_one_channel[&#39;led_area&#39;]) / np.sqrt(
                len(results_one_channel[&#39;led_area&#39;]))

        occ = med / mu
        occ_err = ((med_err / mu)**2 + ((med / mu**2) * mu_err)**2)**0.5
        return occ, occ_err

    def calculate_gain_occ(self, processed_df_single_led: pd.DataFrame,
                           module: int, channel: str,
                           occ_method: str = &#39;mean&#39;) -&gt; Tuple[float, float,
                                                              float, float]:
        &#34;&#34;&#34;Calculates the gain, occupancy and their errors for a given module
        and channel from a dataframe with the processed LED data.

        Args:
            processed_df_single_led (pd.DataFrame): dataframe with the
                processed LED data
            module (int): module to consider
            channel (str): channel to consider
            occ_method (str, optional): Method to calculate the occupancy.
                &#39;mean&#39; or &#39;median&#39;. Defaults to &#39;mean&#39;.

        Returns:
            Tuple[float, float, float, float]: Return the gain, gain_err,
                occ, occ_err of the requested channel.
        &#34;&#34;&#34;

        A, mu, sigma, cov = self.get_1_pe_fit_led(processed_df_single_led,
                                                  module,
                                                  channel)
        A_err, mu_err, sigma_err = np.sqrt(np.diag(cov))

        gain = pylars.utils.common.get_gain(F_amp=20, spe_area=mu) / 1e6
        gain_err = pylars.utils.common.get_gain(
            F_amp=20, spe_area=mu_err) / 1e6

        results_mask = ((processed_df_single_led[&#39;module&#39;] == module) &amp;
                        (processed_df_single_led[&#39;channel&#39;] == channel)
                        )
        occ, occ_err = self.get_occupancy(processed_df_single_led[results_mask],
                                          mu, mu_err, method=occ_method)

        return gain, gain_err, occ, occ_err

    def calculate_all_gains_occ(self):
        &#39;&#39;&#39;Calculate gains and occupancies for all channels available in the
        processed data. The results are stored in self.results_df and a
        registry of failed processing in self.failed_calculation_df.
        &#39;&#39;&#39;

        # Check if processed data exists
        if not hasattr(self, &#39;df_processed&#39;):
            raise AssertionError(
                &#39;No processed data found. Run process_all_datasets first.&#39;)

        results_df = pd.DataFrame(columns=[&#39;Vbias&#39;, &#39;LEDvoltage&#39;,
                                           &#39;LEDwidth&#39;, &#39;module&#39;,
                                           &#39;channel&#39;, &#39;gain&#39;,
                                           &#39;gain_err&#39;, &#39;occ&#39;,
                                           &#39;occ_err&#39;])
        failed_calculation_df = pd.DataFrame(columns=[&#39;Vbias&#39;, &#39;LEDvoltage&#39;,
                                                      &#39;LEDwidth&#39;, &#39;module&#39;,
                                                      &#39;channel&#39;])

        # for i, row in tqdm(self.files_df.iterrows(),
        #                    total=len(self.files_df),
        #                    desc=&#39;Calculating gains and occupancies: &#39;):
        for i, row in self.files_df.iterrows():
            _vbias = row[&#39;Vbias&#39;]
            _led_voltage = row[&#39;LEDvoltage&#39;]
            _led_width = row[&#39;LEDwidth&#39;]
            _module = row[&#39;module&#39;]

            _df_select_processed = self.df_processed[
                (self.df_processed[&#39;Vbias&#39;] == _vbias) &amp;
                (self.df_processed[&#39;LEDvoltage&#39;] == _led_voltage) &amp;
                (self.df_processed[&#39;LEDwidth&#39;] == _led_width)]

            _channels = _df_select_processed[
                _df_select_processed[&#39;module&#39;] == _module][&#39;channel&#39;].unique()

            for _channel in _channels:
                try:
                    _gain, _gain_err, _occ, _occ_err = self.calculate_gain_occ(
                        _df_select_processed, _module, _channel)

                    results_df = pd.concat(
                        (results_df,
                            pd.DataFrame({&#39;Vbias&#39;: [_vbias],
                                          &#39;LEDvoltage&#39;: [_led_voltage],
                                          &#39;LEDwidth&#39;: [_led_width],
                                          &#39;module&#39;: [_module],
                                          &#39;channel&#39;: [_channel],
                                          &#39;gain&#39;: [_gain],
                                          &#39;gain_err&#39;: [_gain_err],
                                          &#39;occ&#39;: [_occ],
                                          &#39;occ_err&#39;: [_occ_err]}),
                         ), ignore_index=True)
                except BaseException:
                    failed_calculation_df = pd.concat(
                        (failed_calculation_df,
                         pd.DataFrame({&#39;Vbias&#39;: [_vbias],
                                       &#39;LEDvoltage&#39;: [_led_voltage],
                                       &#39;LEDwidth&#39;: [_led_width],
                                       &#39;module&#39;: [_module],
                                       &#39;channel&#39;: [_channel]})),
                        ignore_index=True)

        self.failed_calculation_df = failed_calculation_df
        self.results_df = results_df

    def save_gain_results(self, name: str = &#39;&#39;):
        &#34;&#34;&#34;Save the results of the gain and occupancy calculations to a csv
        file.

        Args:
            name (str, optional): name to give to the file. Defaults to &#39;&#39;,
            saving a file with the current timestamp.

        Raises:
            AssertionError: raised if no results dataframe is found in the
                object.
        &#34;&#34;&#34;

        # Check if results exist
        if not hasattr(self, &#39;results_df&#39;):
            raise AssertionError(
                &#39;No results found. Run calculate_all_gains_occ first.&#39;)

        # Save results
        if name == &#39;&#39;:
            now = datetime.datetime.now().isoformat()
            self.results_df.to_csv(f&#39;gain_results_{str(now)}.csv&#39;, index=False)
        else:
            self.results_df.to_csv(f&#39;{name}.csv&#39;, index=False)

    def print_gains_occ_for_wiki(self):
        if not hasattr(self, &#39;df_gains&#39;):
            raise AssertionError(&#39;No computed gains found. Run &#39;
                                 &#39;calculate_all_gains_occ first.&#39;)
        for i, row in self.df_gains.iterrows():  # type: ignore
            print(f&#34;| {row[&#39;tile&#39;]} | {row[&#39;gain&#39;]:.3f} $\\pm$ &#34;  # type: ignore
                  # type: ignore
                  f&#34;{row[&#39;gain_err&#39;]:.3f} | {row[&#39;occ&#39;]:.3f} $\\pm$ &#34;
                  f&#34;{row[&#39;occ_err&#39;]:.3f} |&#34;)

    @staticmethod
    def export_gains(gain_evolution: pd.DataFrame,
                     method: str = &#39;mean&#39;,
                     tag: str = &#39;vx&#39;):
        &#34;&#34;&#34;Export the gains as a single number to a csv file. Method can be
            &#39;mean&#39;, &#39;median&#39; or &#39;last&#39;. Default is &#39;mean&#39;.

        Args:
            gain_evolution (pd.DataFrame): dataframe with the gain evolution
            method (str, optional): method to calculate the number to use as
                gain. Can be &#39;mean&#39;, &#39;median&#39; or &#39;last&#39;. Defaults to &#39;mean&#39;.
            tag (str, optional): Tag to give the gains in the form v#
                (v0,v1,v2,...). Defaults to &#39;vx&#39;.

        Raises:
            ValueError: Raised if the method is not recognized.
        &#34;&#34;&#34;
        if method == &#39;mean&#39;:
            gains = gain_evolution.groupby(
                [&#39;module&#39;, &#39;tile&#39;, &#39;channel&#39;]).mean()
        elif method == &#39;median&#39;:
            gains = gain_evolution.groupby(
                [&#39;module&#39;, &#39;tile&#39;, &#39;channel&#39;]).median()
        elif method == &#39;last&#39;:
            gains = gain_evolution.groupby(
                [&#39;module&#39;, &#39;tile&#39;, &#39;channel&#39;]).last()
        else:
            raise ValueError(&#39;Method not recognized&#39;)

        gains.to_csv(f&#39;gains_{tag}.csv&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pylars.analysis.ledwindow.LED_window"><code class="flex name class">
<span>class <span class="ident">LED_window</span></span>
<span>(</span><span>led_window: Tuple[int, int], led_data_path: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to hold analysis of LED ON data with integrating window.
Use independently of BV datasets.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LED_window():
    &#39;&#39;&#39;Class to hold analysis of LED ON data with integrating window.
    Use independently of BV datasets.
    &#39;&#39;&#39;

    def __init__(self,
                 led_window: Tuple[int, int],
                 led_data_path: str) -&gt; None:
        self.led_window = led_window
        self.led_data_path = led_data_path
        self.baseline_samples = 50
        self.files_df = self.find_files()

    def find_files(self) -&gt; pd.DataFrame:  # type: ignore
        &#39;&#39;&#39;Find the raw data file and the LED data file.
        TODO
        &#39;&#39;&#39;
        pass

        # files = glob.glob(self.led_data_path + &#39;**/*.root&#39;, recursive=True)
        # _dfs = []
        # for f in tqdm(files, desc=&#39;Finding LED data files: &#39;):
        #     try:
        #         _module = int(f.split(&#39;/&#39;)[-1].split(&#39;_&#39;)[4])
        #         _width, _voltage = self.get_LED_width_voltage(f)
        #         _dfs.append({&#39;LEDwidth&#39;: _width,
        #                      &#39;LEDvoltage&#39;: _voltage,
        #                      &#39;module&#39;: _module,
        #                      &#39;path&#39;: f})
        #     except:
        #         print(f&#39;Failed to get info for file {f}&#39;)
        #         continue
        # files_df = pd.DataFrame(_dfs)
        # files_df.sort_values(by=[&#39;LEDwidth&#39;, &#39;LEDvoltage&#39;, &#39;module&#39;],
        #              ignore_index = True, inplace=True)
        # del _dfs, files

        # return files_df

    @staticmethod
    def get_LED_width_voltage(path):
        &#34;&#34;&#34;Read LED width and voltage from the file path.&#34;&#34;&#34;

        root_name_list = path.split(&#39;/&#39;)[-1].split(&#39;_&#39;)
        pulser_width = int(root_name_list[0][:-2])
        voltage = float(root_name_list[1] + &#39;.&#39; + root_name_list[2][0])
        return pulser_width, voltage

    def process_dataset(self, data_path: str, module: int = 0) -&gt; pd.DataFrame:
        &#39;&#39;&#39;Process a dataset with fixwindowprocessor. Requires a raw data file
        and a LED window specified.
        &#39;&#39;&#39;

        processor = pylars.processing.fixwindowprocessor.window_processor(
            baseline_samples=self.baseline_samples,
            led_window=(self.led_window[0], self.led_window[1]))

        processor.load_raw_data(path_to_raw=data_path, module=module)
        df_processed = processor.process_all_channels()
        return df_processed

    def process_all_datasets(self) -&gt; None:
        &#39;&#39;&#39;Process all datasets in the LED data path.
        &#39;&#39;&#39;

        if not hasattr(self, &#39;files_df&#39;):
            raise AssertionError(&#39;No files found. Run find_files first.&#39;)

        _dfs = []
        # for i, row in tqdm(self.files_df.iterrows(),  # type: ignore
        #                    total=len(self.files_df),  # type: ignore
        #                    desc=&#39;Processing LED data: &#39;):^
        for i, row in self.files_df.iterrows():
            _df = self.process_dataset(row[&#39;path&#39;], module=row[&#39;module&#39;])
            _df[&#39;Vbias&#39;] = row[&#39;Vbias&#39;]
            _df[&#39;LEDwidth&#39;] = row[&#39;LEDwidth&#39;]
            _df[&#39;LEDvoltage&#39;] = row[&#39;LEDvoltage&#39;]
            _df[&#39;module&#39;] = row[&#39;module&#39;]
            _dfs.append(_df)
        df_processed = pd.concat(_dfs)
        del _dfs
        df_processed.sort_values(by=[&#39;Vbias&#39;, &#39;LEDvoltage&#39;,
                                     &#39;LEDwidth&#39;, &#39;module&#39;,
                                     &#39;channel&#39;, &#39;wf_number&#39;])

        self.df_processed = df_processed

    def check_settings_available(self):
        &#34;&#34;&#34;Set led_voltages, led_widths and sipms_voltages as object
        attributes.
        &#34;&#34;&#34;

        self.led_voltages = self.files_df[&#39;LEDvoltage&#39;].unique()
        self.led_widths = self.files_df[&#39;LEDwidth&#39;].unique()
        self.sipms_voltages = self.files_df[&#39;Vbias&#39;].unique()

    def get_1_pe_fit_led(self,
                         df_processed: pd.DataFrame,
                         module: int,
                         channel: str) -&gt; Tuple[float, float,
                                                float, np.ndarray]:
        &#34;&#34;&#34;Fit the SPE peak of an LED area hsitogram for a given module and
        channel. Uses scipy.curve_fit with a Gaussian function.

        Args:
            df_processed (pd.DataFrame): dataframe with processed data
            module (int): module to consider
            channel (str): channel to consider

        Returns:
            Tuple[float, float, float, np.ndarray]: A, mu, sigma,
                and cov resulting of the fit
        &#34;&#34;&#34;

        df_processed_mask = (
            (df_processed[&#39;module&#39;] == module) &amp;
            (df_processed[&#39;channel&#39;] == channel))

        hist = np.histogram(df_processed[df_processed_mask][&#39;led_area&#39;],
                            bins=np.linspace(-2000, 20000, 300))
        middle_bins = (hist[1][:-1] + hist[1][1:]) / 2

        try:
            peaks, properties = find_peaks(hist[0],
                                           prominence=100,
                                           distance=5)
            spe_rough = middle_bins[peaks[1]]
        except BaseException:
            spe_rough = 2500
        #if (spe_rough -2000) &gt; 1000: spe_rough = 2000

        spe_mask = np.abs(middle_bins - spe_rough) &lt; spe_rough * 0.5
        (A, mu, sigma), cov = curve_fit(pylars.utils.common.Gaussian,
                                        middle_bins[spe_mask],
                                        hist[0][spe_mask],
                                        p0=[2000, spe_rough,
                                            spe_rough * 0.05])
        return A, mu, sigma, cov

    def get_occupancy(self, results_one_channel: pd.DataFrame,
                      mu: float, mu_err: float,
                      method: str = &#39;mean&#39;) -&gt; Tuple[float, float]:
        &#34;&#34;&#34;Calculate the occupancy of an LED dataset for a given channel.

        Args:
            results_one_channel (pd.DataFrame): dataframe with the results
                of a single channel
            mu (float): the SPE fit mean in ADCcounts
            mu_err (float): error in mu in ADCcounts
            method (str, optional): Method to calculate the occupancy. Either
                &#39;mean&#39; or &#39;median&#39;. Defaults to &#39;mean&#39;.

        Returns:
            Tuple[float, float]: Occupancy and its error. Uses mean by default!
        &#34;&#34;&#34;

        if method == &#39;mean&#39;:
            med = np.mean(results_one_channel[&#39;led_area&#39;])
        elif method == &#39;median&#39;:
            med = np.median(results_one_channel[&#39;led_area&#39;])
        else:
            raise ValueError(
                &#39;Method for occupancy calculation neither mean nor median&#39;)

        med_err = np.std(
            results_one_channel[&#39;led_area&#39;]) / np.sqrt(
                len(results_one_channel[&#39;led_area&#39;]))

        occ = med / mu
        occ_err = ((med_err / mu)**2 + ((med / mu**2) * mu_err)**2)**0.5
        return occ, occ_err

    def calculate_gain_occ(self, processed_df_single_led: pd.DataFrame,
                           module: int, channel: str,
                           occ_method: str = &#39;mean&#39;) -&gt; Tuple[float, float,
                                                              float, float]:
        &#34;&#34;&#34;Calculates the gain, occupancy and their errors for a given module
        and channel from a dataframe with the processed LED data.

        Args:
            processed_df_single_led (pd.DataFrame): dataframe with the
                processed LED data
            module (int): module to consider
            channel (str): channel to consider
            occ_method (str, optional): Method to calculate the occupancy.
                &#39;mean&#39; or &#39;median&#39;. Defaults to &#39;mean&#39;.

        Returns:
            Tuple[float, float, float, float]: Return the gain, gain_err,
                occ, occ_err of the requested channel.
        &#34;&#34;&#34;

        A, mu, sigma, cov = self.get_1_pe_fit_led(processed_df_single_led,
                                                  module,
                                                  channel)
        A_err, mu_err, sigma_err = np.sqrt(np.diag(cov))

        gain = pylars.utils.common.get_gain(F_amp=20, spe_area=mu) / 1e6
        gain_err = pylars.utils.common.get_gain(
            F_amp=20, spe_area=mu_err) / 1e6

        results_mask = ((processed_df_single_led[&#39;module&#39;] == module) &amp;
                        (processed_df_single_led[&#39;channel&#39;] == channel)
                        )
        occ, occ_err = self.get_occupancy(processed_df_single_led[results_mask],
                                          mu, mu_err, method=occ_method)

        return gain, gain_err, occ, occ_err

    def calculate_all_gains_occ(self):
        &#39;&#39;&#39;Calculate gains and occupancies for all channels available in the
        processed data. The results are stored in self.results_df and a
        registry of failed processing in self.failed_calculation_df.
        &#39;&#39;&#39;

        # Check if processed data exists
        if not hasattr(self, &#39;df_processed&#39;):
            raise AssertionError(
                &#39;No processed data found. Run process_all_datasets first.&#39;)

        results_df = pd.DataFrame(columns=[&#39;Vbias&#39;, &#39;LEDvoltage&#39;,
                                           &#39;LEDwidth&#39;, &#39;module&#39;,
                                           &#39;channel&#39;, &#39;gain&#39;,
                                           &#39;gain_err&#39;, &#39;occ&#39;,
                                           &#39;occ_err&#39;])
        failed_calculation_df = pd.DataFrame(columns=[&#39;Vbias&#39;, &#39;LEDvoltage&#39;,
                                                      &#39;LEDwidth&#39;, &#39;module&#39;,
                                                      &#39;channel&#39;])

        # for i, row in tqdm(self.files_df.iterrows(),
        #                    total=len(self.files_df),
        #                    desc=&#39;Calculating gains and occupancies: &#39;):
        for i, row in self.files_df.iterrows():
            _vbias = row[&#39;Vbias&#39;]
            _led_voltage = row[&#39;LEDvoltage&#39;]
            _led_width = row[&#39;LEDwidth&#39;]
            _module = row[&#39;module&#39;]

            _df_select_processed = self.df_processed[
                (self.df_processed[&#39;Vbias&#39;] == _vbias) &amp;
                (self.df_processed[&#39;LEDvoltage&#39;] == _led_voltage) &amp;
                (self.df_processed[&#39;LEDwidth&#39;] == _led_width)]

            _channels = _df_select_processed[
                _df_select_processed[&#39;module&#39;] == _module][&#39;channel&#39;].unique()

            for _channel in _channels:
                try:
                    _gain, _gain_err, _occ, _occ_err = self.calculate_gain_occ(
                        _df_select_processed, _module, _channel)

                    results_df = pd.concat(
                        (results_df,
                            pd.DataFrame({&#39;Vbias&#39;: [_vbias],
                                          &#39;LEDvoltage&#39;: [_led_voltage],
                                          &#39;LEDwidth&#39;: [_led_width],
                                          &#39;module&#39;: [_module],
                                          &#39;channel&#39;: [_channel],
                                          &#39;gain&#39;: [_gain],
                                          &#39;gain_err&#39;: [_gain_err],
                                          &#39;occ&#39;: [_occ],
                                          &#39;occ_err&#39;: [_occ_err]}),
                         ), ignore_index=True)
                except BaseException:
                    failed_calculation_df = pd.concat(
                        (failed_calculation_df,
                         pd.DataFrame({&#39;Vbias&#39;: [_vbias],
                                       &#39;LEDvoltage&#39;: [_led_voltage],
                                       &#39;LEDwidth&#39;: [_led_width],
                                       &#39;module&#39;: [_module],
                                       &#39;channel&#39;: [_channel]})),
                        ignore_index=True)

        self.failed_calculation_df = failed_calculation_df
        self.results_df = results_df

    def save_gain_results(self, name: str = &#39;&#39;):
        &#34;&#34;&#34;Save the results of the gain and occupancy calculations to a csv
        file.

        Args:
            name (str, optional): name to give to the file. Defaults to &#39;&#39;,
            saving a file with the current timestamp.

        Raises:
            AssertionError: raised if no results dataframe is found in the
                object.
        &#34;&#34;&#34;

        # Check if results exist
        if not hasattr(self, &#39;results_df&#39;):
            raise AssertionError(
                &#39;No results found. Run calculate_all_gains_occ first.&#39;)

        # Save results
        if name == &#39;&#39;:
            now = datetime.datetime.now().isoformat()
            self.results_df.to_csv(f&#39;gain_results_{str(now)}.csv&#39;, index=False)
        else:
            self.results_df.to_csv(f&#39;{name}.csv&#39;, index=False)

    def print_gains_occ_for_wiki(self):
        if not hasattr(self, &#39;df_gains&#39;):
            raise AssertionError(&#39;No computed gains found. Run &#39;
                                 &#39;calculate_all_gains_occ first.&#39;)
        for i, row in self.df_gains.iterrows():  # type: ignore
            print(f&#34;| {row[&#39;tile&#39;]} | {row[&#39;gain&#39;]:.3f} $\\pm$ &#34;  # type: ignore
                  # type: ignore
                  f&#34;{row[&#39;gain_err&#39;]:.3f} | {row[&#39;occ&#39;]:.3f} $\\pm$ &#34;
                  f&#34;{row[&#39;occ_err&#39;]:.3f} |&#34;)

    @staticmethod
    def export_gains(gain_evolution: pd.DataFrame,
                     method: str = &#39;mean&#39;,
                     tag: str = &#39;vx&#39;):
        &#34;&#34;&#34;Export the gains as a single number to a csv file. Method can be
            &#39;mean&#39;, &#39;median&#39; or &#39;last&#39;. Default is &#39;mean&#39;.

        Args:
            gain_evolution (pd.DataFrame): dataframe with the gain evolution
            method (str, optional): method to calculate the number to use as
                gain. Can be &#39;mean&#39;, &#39;median&#39; or &#39;last&#39;. Defaults to &#39;mean&#39;.
            tag (str, optional): Tag to give the gains in the form v#
                (v0,v1,v2,...). Defaults to &#39;vx&#39;.

        Raises:
            ValueError: Raised if the method is not recognized.
        &#34;&#34;&#34;
        if method == &#39;mean&#39;:
            gains = gain_evolution.groupby(
                [&#39;module&#39;, &#39;tile&#39;, &#39;channel&#39;]).mean()
        elif method == &#39;median&#39;:
            gains = gain_evolution.groupby(
                [&#39;module&#39;, &#39;tile&#39;, &#39;channel&#39;]).median()
        elif method == &#39;last&#39;:
            gains = gain_evolution.groupby(
                [&#39;module&#39;, &#39;tile&#39;, &#39;channel&#39;]).last()
        else:
            raise ValueError(&#39;Method not recognized&#39;)

        gains.to_csv(f&#39;gains_{tag}.csv&#39;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pylars.analysis.ledwindow.LED_window.export_gains"><code class="name flex">
<span>def <span class="ident">export_gains</span></span>(<span>gain_evolution: pandas.core.frame.DataFrame, method: str = 'mean', tag: str = 'vx')</span>
</code></dt>
<dd>
<div class="desc"><p>Export the gains as a single number to a csv file. Method can be
'mean', 'median' or 'last'. Default is 'mean'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>gain_evolution</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>dataframe with the gain evolution</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>method to calculate the number to use as
gain. Can be 'mean', 'median' or 'last'. Defaults to 'mean'.</dd>
<dt><strong><code>tag</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Tag to give the gains in the form v#
(v0,v1,v2,&hellip;). Defaults to 'vx'.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Raised if the method is not recognized.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def export_gains(gain_evolution: pd.DataFrame,
                 method: str = &#39;mean&#39;,
                 tag: str = &#39;vx&#39;):
    &#34;&#34;&#34;Export the gains as a single number to a csv file. Method can be
        &#39;mean&#39;, &#39;median&#39; or &#39;last&#39;. Default is &#39;mean&#39;.

    Args:
        gain_evolution (pd.DataFrame): dataframe with the gain evolution
        method (str, optional): method to calculate the number to use as
            gain. Can be &#39;mean&#39;, &#39;median&#39; or &#39;last&#39;. Defaults to &#39;mean&#39;.
        tag (str, optional): Tag to give the gains in the form v#
            (v0,v1,v2,...). Defaults to &#39;vx&#39;.

    Raises:
        ValueError: Raised if the method is not recognized.
    &#34;&#34;&#34;
    if method == &#39;mean&#39;:
        gains = gain_evolution.groupby(
            [&#39;module&#39;, &#39;tile&#39;, &#39;channel&#39;]).mean()
    elif method == &#39;median&#39;:
        gains = gain_evolution.groupby(
            [&#39;module&#39;, &#39;tile&#39;, &#39;channel&#39;]).median()
    elif method == &#39;last&#39;:
        gains = gain_evolution.groupby(
            [&#39;module&#39;, &#39;tile&#39;, &#39;channel&#39;]).last()
    else:
        raise ValueError(&#39;Method not recognized&#39;)

    gains.to_csv(f&#39;gains_{tag}.csv&#39;)</code></pre>
</details>
</dd>
<dt id="pylars.analysis.ledwindow.LED_window.get_LED_width_voltage"><code class="name flex">
<span>def <span class="ident">get_LED_width_voltage</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Read LED width and voltage from the file path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_LED_width_voltage(path):
    &#34;&#34;&#34;Read LED width and voltage from the file path.&#34;&#34;&#34;

    root_name_list = path.split(&#39;/&#39;)[-1].split(&#39;_&#39;)
    pulser_width = int(root_name_list[0][:-2])
    voltage = float(root_name_list[1] + &#39;.&#39; + root_name_list[2][0])
    return pulser_width, voltage</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pylars.analysis.ledwindow.LED_window.calculate_all_gains_occ"><code class="name flex">
<span>def <span class="ident">calculate_all_gains_occ</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate gains and occupancies for all channels available in the
processed data. The results are stored in self.results_df and a
registry of failed processing in self.failed_calculation_df.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_all_gains_occ(self):
    &#39;&#39;&#39;Calculate gains and occupancies for all channels available in the
    processed data. The results are stored in self.results_df and a
    registry of failed processing in self.failed_calculation_df.
    &#39;&#39;&#39;

    # Check if processed data exists
    if not hasattr(self, &#39;df_processed&#39;):
        raise AssertionError(
            &#39;No processed data found. Run process_all_datasets first.&#39;)

    results_df = pd.DataFrame(columns=[&#39;Vbias&#39;, &#39;LEDvoltage&#39;,
                                       &#39;LEDwidth&#39;, &#39;module&#39;,
                                       &#39;channel&#39;, &#39;gain&#39;,
                                       &#39;gain_err&#39;, &#39;occ&#39;,
                                       &#39;occ_err&#39;])
    failed_calculation_df = pd.DataFrame(columns=[&#39;Vbias&#39;, &#39;LEDvoltage&#39;,
                                                  &#39;LEDwidth&#39;, &#39;module&#39;,
                                                  &#39;channel&#39;])

    # for i, row in tqdm(self.files_df.iterrows(),
    #                    total=len(self.files_df),
    #                    desc=&#39;Calculating gains and occupancies: &#39;):
    for i, row in self.files_df.iterrows():
        _vbias = row[&#39;Vbias&#39;]
        _led_voltage = row[&#39;LEDvoltage&#39;]
        _led_width = row[&#39;LEDwidth&#39;]
        _module = row[&#39;module&#39;]

        _df_select_processed = self.df_processed[
            (self.df_processed[&#39;Vbias&#39;] == _vbias) &amp;
            (self.df_processed[&#39;LEDvoltage&#39;] == _led_voltage) &amp;
            (self.df_processed[&#39;LEDwidth&#39;] == _led_width)]

        _channels = _df_select_processed[
            _df_select_processed[&#39;module&#39;] == _module][&#39;channel&#39;].unique()

        for _channel in _channels:
            try:
                _gain, _gain_err, _occ, _occ_err = self.calculate_gain_occ(
                    _df_select_processed, _module, _channel)

                results_df = pd.concat(
                    (results_df,
                        pd.DataFrame({&#39;Vbias&#39;: [_vbias],
                                      &#39;LEDvoltage&#39;: [_led_voltage],
                                      &#39;LEDwidth&#39;: [_led_width],
                                      &#39;module&#39;: [_module],
                                      &#39;channel&#39;: [_channel],
                                      &#39;gain&#39;: [_gain],
                                      &#39;gain_err&#39;: [_gain_err],
                                      &#39;occ&#39;: [_occ],
                                      &#39;occ_err&#39;: [_occ_err]}),
                     ), ignore_index=True)
            except BaseException:
                failed_calculation_df = pd.concat(
                    (failed_calculation_df,
                     pd.DataFrame({&#39;Vbias&#39;: [_vbias],
                                   &#39;LEDvoltage&#39;: [_led_voltage],
                                   &#39;LEDwidth&#39;: [_led_width],
                                   &#39;module&#39;: [_module],
                                   &#39;channel&#39;: [_channel]})),
                    ignore_index=True)

    self.failed_calculation_df = failed_calculation_df
    self.results_df = results_df</code></pre>
</details>
</dd>
<dt id="pylars.analysis.ledwindow.LED_window.calculate_gain_occ"><code class="name flex">
<span>def <span class="ident">calculate_gain_occ</span></span>(<span>self, processed_df_single_led: pandas.core.frame.DataFrame, module: int, channel: str, occ_method: str = 'mean') ‑> Tuple[float, float, float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the gain, occupancy and their errors for a given module
and channel from a dataframe with the processed LED data.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>processed_df_single_led</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>dataframe with the
processed LED data</dd>
<dt><strong><code>module</code></strong> :&ensp;<code>int</code></dt>
<dd>module to consider</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>str</code></dt>
<dd>channel to consider</dd>
<dt><strong><code>occ_method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Method to calculate the occupancy.
'mean' or 'median'. Defaults to 'mean'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[float, float, float, float]</code></dt>
<dd>Return the gain, gain_err,
occ, occ_err of the requested channel.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_gain_occ(self, processed_df_single_led: pd.DataFrame,
                       module: int, channel: str,
                       occ_method: str = &#39;mean&#39;) -&gt; Tuple[float, float,
                                                          float, float]:
    &#34;&#34;&#34;Calculates the gain, occupancy and their errors for a given module
    and channel from a dataframe with the processed LED data.

    Args:
        processed_df_single_led (pd.DataFrame): dataframe with the
            processed LED data
        module (int): module to consider
        channel (str): channel to consider
        occ_method (str, optional): Method to calculate the occupancy.
            &#39;mean&#39; or &#39;median&#39;. Defaults to &#39;mean&#39;.

    Returns:
        Tuple[float, float, float, float]: Return the gain, gain_err,
            occ, occ_err of the requested channel.
    &#34;&#34;&#34;

    A, mu, sigma, cov = self.get_1_pe_fit_led(processed_df_single_led,
                                              module,
                                              channel)
    A_err, mu_err, sigma_err = np.sqrt(np.diag(cov))

    gain = pylars.utils.common.get_gain(F_amp=20, spe_area=mu) / 1e6
    gain_err = pylars.utils.common.get_gain(
        F_amp=20, spe_area=mu_err) / 1e6

    results_mask = ((processed_df_single_led[&#39;module&#39;] == module) &amp;
                    (processed_df_single_led[&#39;channel&#39;] == channel)
                    )
    occ, occ_err = self.get_occupancy(processed_df_single_led[results_mask],
                                      mu, mu_err, method=occ_method)

    return gain, gain_err, occ, occ_err</code></pre>
</details>
</dd>
<dt id="pylars.analysis.ledwindow.LED_window.check_settings_available"><code class="name flex">
<span>def <span class="ident">check_settings_available</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set led_voltages, led_widths and sipms_voltages as object
attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_settings_available(self):
    &#34;&#34;&#34;Set led_voltages, led_widths and sipms_voltages as object
    attributes.
    &#34;&#34;&#34;

    self.led_voltages = self.files_df[&#39;LEDvoltage&#39;].unique()
    self.led_widths = self.files_df[&#39;LEDwidth&#39;].unique()
    self.sipms_voltages = self.files_df[&#39;Vbias&#39;].unique()</code></pre>
</details>
</dd>
<dt id="pylars.analysis.ledwindow.LED_window.find_files"><code class="name flex">
<span>def <span class="ident">find_files</span></span>(<span>self) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Find the raw data file and the LED data file.
TODO</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_files(self) -&gt; pd.DataFrame:  # type: ignore
    &#39;&#39;&#39;Find the raw data file and the LED data file.
    TODO
    &#39;&#39;&#39;
    pass

    # files = glob.glob(self.led_data_path + &#39;**/*.root&#39;, recursive=True)
    # _dfs = []
    # for f in tqdm(files, desc=&#39;Finding LED data files: &#39;):
    #     try:
    #         _module = int(f.split(&#39;/&#39;)[-1].split(&#39;_&#39;)[4])
    #         _width, _voltage = self.get_LED_width_voltage(f)
    #         _dfs.append({&#39;LEDwidth&#39;: _width,
    #                      &#39;LEDvoltage&#39;: _voltage,
    #                      &#39;module&#39;: _module,
    #                      &#39;path&#39;: f})
    #     except:
    #         print(f&#39;Failed to get info for file {f}&#39;)
    #         continue
    # files_df = pd.DataFrame(_dfs)
    # files_df.sort_values(by=[&#39;LEDwidth&#39;, &#39;LEDvoltage&#39;, &#39;module&#39;],
    #              ignore_index = True, inplace=True)
    # del _dfs, files

    # return files_df</code></pre>
</details>
</dd>
<dt id="pylars.analysis.ledwindow.LED_window.get_1_pe_fit_led"><code class="name flex">
<span>def <span class="ident">get_1_pe_fit_led</span></span>(<span>self, df_processed: pandas.core.frame.DataFrame, module: int, channel: str) ‑> Tuple[float, float, float, numpy.ndarray]</span>
</code></dt>
<dd>
<div class="desc"><p>Fit the SPE peak of an LED area hsitogram for a given module and
channel. Uses scipy.curve_fit with a Gaussian function.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>df_processed</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>dataframe with processed data</dd>
<dt><strong><code>module</code></strong> :&ensp;<code>int</code></dt>
<dd>module to consider</dd>
<dt><strong><code>channel</code></strong> :&ensp;<code>str</code></dt>
<dd>channel to consider</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[float, float, float, np.ndarray]</code></dt>
<dd>A, mu, sigma,
and cov resulting of the fit</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_1_pe_fit_led(self,
                     df_processed: pd.DataFrame,
                     module: int,
                     channel: str) -&gt; Tuple[float, float,
                                            float, np.ndarray]:
    &#34;&#34;&#34;Fit the SPE peak of an LED area hsitogram for a given module and
    channel. Uses scipy.curve_fit with a Gaussian function.

    Args:
        df_processed (pd.DataFrame): dataframe with processed data
        module (int): module to consider
        channel (str): channel to consider

    Returns:
        Tuple[float, float, float, np.ndarray]: A, mu, sigma,
            and cov resulting of the fit
    &#34;&#34;&#34;

    df_processed_mask = (
        (df_processed[&#39;module&#39;] == module) &amp;
        (df_processed[&#39;channel&#39;] == channel))

    hist = np.histogram(df_processed[df_processed_mask][&#39;led_area&#39;],
                        bins=np.linspace(-2000, 20000, 300))
    middle_bins = (hist[1][:-1] + hist[1][1:]) / 2

    try:
        peaks, properties = find_peaks(hist[0],
                                       prominence=100,
                                       distance=5)
        spe_rough = middle_bins[peaks[1]]
    except BaseException:
        spe_rough = 2500
    #if (spe_rough -2000) &gt; 1000: spe_rough = 2000

    spe_mask = np.abs(middle_bins - spe_rough) &lt; spe_rough * 0.5
    (A, mu, sigma), cov = curve_fit(pylars.utils.common.Gaussian,
                                    middle_bins[spe_mask],
                                    hist[0][spe_mask],
                                    p0=[2000, spe_rough,
                                        spe_rough * 0.05])
    return A, mu, sigma, cov</code></pre>
</details>
</dd>
<dt id="pylars.analysis.ledwindow.LED_window.get_occupancy"><code class="name flex">
<span>def <span class="ident">get_occupancy</span></span>(<span>self, results_one_channel: pandas.core.frame.DataFrame, mu: float, mu_err: float, method: str = 'mean') ‑> Tuple[float, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate the occupancy of an LED dataset for a given channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>results_one_channel</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>dataframe with the results
of a single channel</dd>
<dt><strong><code>mu</code></strong> :&ensp;<code>float</code></dt>
<dd>the SPE fit mean in ADCcounts</dd>
<dt><strong><code>mu_err</code></strong> :&ensp;<code>float</code></dt>
<dd>error in mu in ADCcounts</dd>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Method to calculate the occupancy. Either
'mean' or 'median'. Defaults to 'mean'.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[float, float]</code></dt>
<dd>Occupancy and its error. Uses mean by default!</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_occupancy(self, results_one_channel: pd.DataFrame,
                  mu: float, mu_err: float,
                  method: str = &#39;mean&#39;) -&gt; Tuple[float, float]:
    &#34;&#34;&#34;Calculate the occupancy of an LED dataset for a given channel.

    Args:
        results_one_channel (pd.DataFrame): dataframe with the results
            of a single channel
        mu (float): the SPE fit mean in ADCcounts
        mu_err (float): error in mu in ADCcounts
        method (str, optional): Method to calculate the occupancy. Either
            &#39;mean&#39; or &#39;median&#39;. Defaults to &#39;mean&#39;.

    Returns:
        Tuple[float, float]: Occupancy and its error. Uses mean by default!
    &#34;&#34;&#34;

    if method == &#39;mean&#39;:
        med = np.mean(results_one_channel[&#39;led_area&#39;])
    elif method == &#39;median&#39;:
        med = np.median(results_one_channel[&#39;led_area&#39;])
    else:
        raise ValueError(
            &#39;Method for occupancy calculation neither mean nor median&#39;)

    med_err = np.std(
        results_one_channel[&#39;led_area&#39;]) / np.sqrt(
            len(results_one_channel[&#39;led_area&#39;]))

    occ = med / mu
    occ_err = ((med_err / mu)**2 + ((med / mu**2) * mu_err)**2)**0.5
    return occ, occ_err</code></pre>
</details>
</dd>
<dt id="pylars.analysis.ledwindow.LED_window.print_gains_occ_for_wiki"><code class="name flex">
<span>def <span class="ident">print_gains_occ_for_wiki</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_gains_occ_for_wiki(self):
    if not hasattr(self, &#39;df_gains&#39;):
        raise AssertionError(&#39;No computed gains found. Run &#39;
                             &#39;calculate_all_gains_occ first.&#39;)
    for i, row in self.df_gains.iterrows():  # type: ignore
        print(f&#34;| {row[&#39;tile&#39;]} | {row[&#39;gain&#39;]:.3f} $\\pm$ &#34;  # type: ignore
              # type: ignore
              f&#34;{row[&#39;gain_err&#39;]:.3f} | {row[&#39;occ&#39;]:.3f} $\\pm$ &#34;
              f&#34;{row[&#39;occ_err&#39;]:.3f} |&#34;)</code></pre>
</details>
</dd>
<dt id="pylars.analysis.ledwindow.LED_window.process_all_datasets"><code class="name flex">
<span>def <span class="ident">process_all_datasets</span></span>(<span>self) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Process all datasets in the LED data path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_all_datasets(self) -&gt; None:
    &#39;&#39;&#39;Process all datasets in the LED data path.
    &#39;&#39;&#39;

    if not hasattr(self, &#39;files_df&#39;):
        raise AssertionError(&#39;No files found. Run find_files first.&#39;)

    _dfs = []
    # for i, row in tqdm(self.files_df.iterrows(),  # type: ignore
    #                    total=len(self.files_df),  # type: ignore
    #                    desc=&#39;Processing LED data: &#39;):^
    for i, row in self.files_df.iterrows():
        _df = self.process_dataset(row[&#39;path&#39;], module=row[&#39;module&#39;])
        _df[&#39;Vbias&#39;] = row[&#39;Vbias&#39;]
        _df[&#39;LEDwidth&#39;] = row[&#39;LEDwidth&#39;]
        _df[&#39;LEDvoltage&#39;] = row[&#39;LEDvoltage&#39;]
        _df[&#39;module&#39;] = row[&#39;module&#39;]
        _dfs.append(_df)
    df_processed = pd.concat(_dfs)
    del _dfs
    df_processed.sort_values(by=[&#39;Vbias&#39;, &#39;LEDvoltage&#39;,
                                 &#39;LEDwidth&#39;, &#39;module&#39;,
                                 &#39;channel&#39;, &#39;wf_number&#39;])

    self.df_processed = df_processed</code></pre>
</details>
</dd>
<dt id="pylars.analysis.ledwindow.LED_window.process_dataset"><code class="name flex">
<span>def <span class="ident">process_dataset</span></span>(<span>self, data_path: str, module: int = 0) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Process a dataset with fixwindowprocessor. Requires a raw data file
and a LED window specified.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_dataset(self, data_path: str, module: int = 0) -&gt; pd.DataFrame:
    &#39;&#39;&#39;Process a dataset with fixwindowprocessor. Requires a raw data file
    and a LED window specified.
    &#39;&#39;&#39;

    processor = pylars.processing.fixwindowprocessor.window_processor(
        baseline_samples=self.baseline_samples,
        led_window=(self.led_window[0], self.led_window[1]))

    processor.load_raw_data(path_to_raw=data_path, module=module)
    df_processed = processor.process_all_channels()
    return df_processed</code></pre>
</details>
</dd>
<dt id="pylars.analysis.ledwindow.LED_window.save_gain_results"><code class="name flex">
<span>def <span class="ident">save_gain_results</span></span>(<span>self, name: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Save the results of the gain and occupancy calculations to a csv
file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>name to give to the file. Defaults to '',</dd>
</dl>
<p>saving a file with the current timestamp.</p>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>AssertionError</code></dt>
<dd>raised if no results dataframe is found in the
object.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_gain_results(self, name: str = &#39;&#39;):
    &#34;&#34;&#34;Save the results of the gain and occupancy calculations to a csv
    file.

    Args:
        name (str, optional): name to give to the file. Defaults to &#39;&#39;,
        saving a file with the current timestamp.

    Raises:
        AssertionError: raised if no results dataframe is found in the
            object.
    &#34;&#34;&#34;

    # Check if results exist
    if not hasattr(self, &#39;results_df&#39;):
        raise AssertionError(
            &#39;No results found. Run calculate_all_gains_occ first.&#39;)

    # Save results
    if name == &#39;&#39;:
        now = datetime.datetime.now().isoformat()
        self.results_df.to_csv(f&#39;gain_results_{str(now)}.csv&#39;, index=False)
    else:
        self.results_df.to_csv(f&#39;{name}.csv&#39;, index=False)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pylars.analysis" href="index.html">pylars.analysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pylars.analysis.ledwindow.LED_window" href="#pylars.analysis.ledwindow.LED_window">LED_window</a></code></h4>
<ul class="">
<li><code><a title="pylars.analysis.ledwindow.LED_window.calculate_all_gains_occ" href="#pylars.analysis.ledwindow.LED_window.calculate_all_gains_occ">calculate_all_gains_occ</a></code></li>
<li><code><a title="pylars.analysis.ledwindow.LED_window.calculate_gain_occ" href="#pylars.analysis.ledwindow.LED_window.calculate_gain_occ">calculate_gain_occ</a></code></li>
<li><code><a title="pylars.analysis.ledwindow.LED_window.check_settings_available" href="#pylars.analysis.ledwindow.LED_window.check_settings_available">check_settings_available</a></code></li>
<li><code><a title="pylars.analysis.ledwindow.LED_window.export_gains" href="#pylars.analysis.ledwindow.LED_window.export_gains">export_gains</a></code></li>
<li><code><a title="pylars.analysis.ledwindow.LED_window.find_files" href="#pylars.analysis.ledwindow.LED_window.find_files">find_files</a></code></li>
<li><code><a title="pylars.analysis.ledwindow.LED_window.get_1_pe_fit_led" href="#pylars.analysis.ledwindow.LED_window.get_1_pe_fit_led">get_1_pe_fit_led</a></code></li>
<li><code><a title="pylars.analysis.ledwindow.LED_window.get_LED_width_voltage" href="#pylars.analysis.ledwindow.LED_window.get_LED_width_voltage">get_LED_width_voltage</a></code></li>
<li><code><a title="pylars.analysis.ledwindow.LED_window.get_occupancy" href="#pylars.analysis.ledwindow.LED_window.get_occupancy">get_occupancy</a></code></li>
<li><code><a title="pylars.analysis.ledwindow.LED_window.print_gains_occ_for_wiki" href="#pylars.analysis.ledwindow.LED_window.print_gains_occ_for_wiki">print_gains_occ_for_wiki</a></code></li>
<li><code><a title="pylars.analysis.ledwindow.LED_window.process_all_datasets" href="#pylars.analysis.ledwindow.LED_window.process_all_datasets">process_all_datasets</a></code></li>
<li><code><a title="pylars.analysis.ledwindow.LED_window.process_dataset" href="#pylars.analysis.ledwindow.LED_window.process_dataset">process_dataset</a></code></li>
<li><code><a title="pylars.analysis.ledwindow.LED_window.save_gain_results" href="#pylars.analysis.ledwindow.LED_window.save_gain_results">save_gain_results</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>